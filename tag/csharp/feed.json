{
    "version": "https://jsonfeed.org/version/1",
    "title": "SamHou's blog • All posts by \"csharp\" tag",
    "description": "SamHou 的一个博客，有技术文章，小说和生活学习方法分享。包含 C#、html、css、NAS、windows 的技术博客文章，以及大量二次创作小说和原创作品。",
    "home_page_url": "https://blog.samhou.top",
    "items": [
        {
            "id": "https://blog.samhou.top/Winform%20Csharp%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/",
            "url": "https://blog.samhou.top/Winform%20Csharp%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/",
            "title": "Winform C#多显示器窗口控制详解",
            "date_published": "2023-12-08T07:12:38.000Z",
            "content_html": "<p>写Winform程序的时候，有将一个窗口放置到特定的显示器，并且全屏的需求。于是借此机会，好好研究了一番这个Screen类[1]，总结了一些方法。</p>\n<h2 id=\"Windows的窗口逻辑\"><a href=\"#Windows的窗口逻辑\" class=\"headerlink\" title=\"Windows的窗口逻辑\"></a>Windows的窗口逻辑</h2><p>首先我们需要知道窗口定位的逻辑。以2个窗口为例，下面的图片展示了显示器和坐标的对应关系。注意，使用深色模式可能看不清，可以点击上方的切换按钮切换为浅色。</p>\n<p><img src=\"https://img.samhou.top/1702026494796.png\" alt=\"显示器与坐标对应\"></p>\n<p>可以看到，连接多个显示器后，每个显示器的每个点都有一个唯一的坐标。我们要做的，就是把Form的坐标设置到显示器上面去。</p>\n<h2 id=\"获取显示器列表\"><a href=\"#获取显示器列表\" class=\"headerlink\" title=\"获取显示器列表\"></a>获取显示器列表</h2><p>首先确保引用了<code>using System.Windows.Forms;</code>，这样才有Screen类可以用。</p>\n<p>文档指出，可以用<code>Screen.AllScreens</code>获取所有显示器的数组。那么这个里面有什么呢？我们来看看文档是怎么说的：</p>\n<blockquote>\n<p>Property Value<br><a href=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.screen?view=windowsdesktop-8.0\">Screen</a>[]<br>An array of type <a href=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.screen?view=windowsdesktop-8.0\">Screen</a>, containing all displays on the system.</p>\n</blockquote>\n<p>也就是说，返回的数组是个Screen数组。数组里面每一个元素都是个Screen对象，分别对应用户的每个显示设备。因此，我们可以通过这些对象来访问每个显示器。比如：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Screen scr1=Screen.AllScreens[<span class=\"number\">0</span>] <span class=\"comment\">//获取第1个显示器</span></span><br><span class=\"line\">Screen scr2=Screen.AllScreens[<span class=\"number\">1</span>]<span class=\"comment\">//第二个显示器</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置窗口位置\"><a href=\"#设置窗口位置\" class=\"headerlink\" title=\"设置窗口位置\"></a>设置窗口位置</h2><p>为了设定窗口位置，我们需要知道一个显示器左上角对应的坐标，这样才可以把窗口放进去。</p>\n<p>比如，以下代码可以设置Form位置为第2个显示器的左上角，然后设置窗口覆盖全屏幕（包括任务栏：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Location = Screen.AllScreens[<span class=\"number\">1</span>].Bounds.Location;<span class=\"comment\">//设定目标坐标，结合上面的图片，这里是（1920，28）</span></span><br><span class=\"line\">Width = Screen.AllScreens[<span class=\"number\">1</span>].Bounds.Width;<span class=\"comment\">//设定窗口的宽度</span></span><br><span class=\"line\">Height = Screen.AllScreens[<span class=\"number\">1</span>].Bounds.Height;<span class=\"comment\">//设定窗口高度</span></span><br></pre></td></tr></table></figure>\n\n<p>但大部分情况下，我们只需要覆盖任务栏之上的部分，因此稍作修改：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Location = Screen.AllScreens[<span class=\"number\">1</span>].WorkingArea.Location;<span class=\"comment\">//设定目标显示器</span></span><br><span class=\"line\">Width = Screen.AllScreens[<span class=\"number\">1</span>].WorkingArea.Width;<span class=\"comment\">//设定窗口的宽度</span></span><br><span class=\"line\">Height = Screen.AllScreens[<span class=\"number\">1</span>].WorkingArea.Height;<span class=\"comment\">//设定窗口高度</span></span><br></pre></td></tr></table></figure>\n\n<p>注意到了吗？这里我们用的是<code>WorkingArea</code>来获取长宽高，以及位置。<code>WorkingArea</code>不包括任务栏，所以高度较少，这两种需要看情况使用。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1] <a href=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.screen\">System.Windows.Forms.Screen</a></p>\n",
            "tags": [
                "csharp",
                "窗口控制",
                "winform"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E7%84%A6%E7%82%B9(%E5%89%8D%E5%8F%B0%E7%AA%97%E5%8F%A3)/",
            "url": "https://blog.samhou.top/Csharp%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E7%84%A6%E7%82%B9(%E5%89%8D%E5%8F%B0%E7%AA%97%E5%8F%A3)/",
            "title": "Csharp强制设置系统焦点(前台窗口)",
            "date_published": "2023-01-27T01:01:20.000Z",
            "content_html": "<h2 id=\"系统焦点\"><a href=\"#系统焦点\" class=\"headerlink\" title=\"系统焦点\"></a>系统焦点</h2><p>在Windows中，系统的焦点就是当前处于前台的窗口。通过设置焦点，可以控制用户正在使用的应用程序。这里以winform应用为例。</p>\n<h2 id=\"Api调用\"><a href=\"#Api调用\" class=\"headerlink\" title=\"Api调用\"></a>Api调用</h2><p>C#需要调用Win32 Api才可以控制焦点，这里用到的是user32.dll中的SetForegroundWindow()函数</p>\n<p>在微软提供的文档中[1]，可以看到C++里的用法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">SetForegroundWindow</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  [in] HWND hWnd<span class=\"comment\">//窗口句柄</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>C#里没有HWND类型，与之对应的是IntPtr类型，所以可以这样导入Api[2]</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Runtime.InteropServices;<span class=\"comment\">//这是调用所必须的</span></span><br><span class=\"line\">[<span class=\"meta\">DllImport(<span class=\"string\">&quot;user32.dll&quot;</span>)</span>]<span class=\"comment\">//调用dll</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"built_in\">bool</span> <span class=\"title\">SetForegroundWindow</span>(<span class=\"params\">IntPtr handle</span>)</span>;<span class=\"comment\">//这个函数签名必须和文档一模一样</span></span><br></pre></td></tr></table></figure>\n\n<p>下面来调用导入的内容（以设置edge浏览器为例子）</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process[] processes = Process.GetProcessesByName(<span class=\"string\">&quot;msedge&quot;</span>);<span class=\"comment\">//查找edge浏览器进程</span></span><br><span class=\"line\">IntPtr handle = processes[<span class=\"number\">0</span>].MainWindowHandle;<span class=\"comment\">//获取主窗口句柄</span></span><br><span class=\"line\">SetForegroundWindow(handle);</span><br></pre></td></tr></table></figure>\n\n<p>但是，文档上指出这样设置需要满足几个条件中的任意一个：</p>\n<blockquote>\n<p>此过程是前台进程。&#x2F;进程由前台进程启动。&#x2F;进程收到了最后一个输入事件。&#x2F;没有前台进程。&#x2F;正在调试该过程。&#x2F;前台进程不是新式应用程序或“开始”屏幕。&#x2F;前台未锁定， (请参阅 <a href=\"https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-locksetforegroundwindow\">LockSetForegroundWindow</a>) 。&#x2F;前台锁定超时已过期， (在 <a href=\"https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa\">SystemParametersInfo</a>) 中看到<strong>SPI_GETFOREGROUNDLOCKTIMEOUT</strong>。&#x2F;没有活动菜单。&#x2F;当用户使用另一个窗口时，应用程序无法强制将窗口强制到前台。 相反，Windows 会闪烁窗口的任务栏按钮以通知用户。</p>\n</blockquote>\n<p>这样就不能说是强制设置了（注意，调试程序时系统允许强制设置，但只要离开调试器，就不行了），所以下面给出一个特别的方法。</p>\n<h2 id=\"强制设置\"><a href=\"#强制设置\" class=\"headerlink\" title=\"强制设置\"></a>强制设置</h2><p>Windows中，只要是新启动的窗口，总是能够获得系统的焦点。所以只要让程序重新启动，就能拿到焦点，变成前台进程，此时就可以设置焦点，达到强制的效果。</p>\n<p>这里还用到了另一个Api <code>GetForegroundWindow()</code>用于获取当前焦点[3]，调用方式同上，此处不再解释。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">DllImport(<span class=\"string\">&quot;user32.dll&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> IntPtr <span class=\"title\">GetForegroundWindow</span>()</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">Process[] processes = Process.GetProcessesByName(<span class=\"string\">&quot;msedge&quot;</span>);</span><br><span class=\"line\">IntPtr handle = processes[<span class=\"number\">0</span>].MainWindowHandle;</span><br><span class=\"line\">SetForegroundWindow(handle);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (handle!=GetForegroundWindow())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     Process.Start(Application.ExecutablePath);</span><br><span class=\"line\">     Environment.Exit(<span class=\"number\">0</span>);<span class=\"comment\">//重启</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，该方法仅30%成功率，若连续10次重启仍未获得焦点，建议放弃(</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] <a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow\">https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow</a></p>\n<p>[2] <a href=\"https://www.cnblogs.com/code1992/p/5965997.html\">https://www.cnblogs.com/code1992/p/5965997.html</a></p>\n<p>[3] <a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getforegroundwindow\">https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getforegroundwindow</a></p>\n",
            "tags": [
                "csharp",
                "窗口控制",
                "焦点",
                "windows"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E6%8E%A5%E5%8F%A3%E8%BF%9B%E9%98%B6/",
            "url": "https://blog.samhou.top/Csharp%E6%8E%A5%E5%8F%A3%E8%BF%9B%E9%98%B6/",
            "title": "Csharp接口进阶",
            "date_published": "2022-12-30T13:12:24.000Z",
            "content_html": "<p>在<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"这篇文章\">这篇文章</a>里，曾经讲解过C#接口的基本概念。掌握这些基本概念后，本文将补充一个进阶内容。</p>\n<h2 id=\"显式接口成员实现\"><a href=\"#显式接口成员实现\" class=\"headerlink\" title=\"显式接口成员实现\"></a>显式接口成员实现</h2><ul>\n<li>该功能用于为同一个类中实现的不同接口创建不同的方法（方法名称相同）</li>\n<li>语法：</li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title\">I1</span>&#123;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Method</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title\">I2</span>&#123;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Method</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span>:<span class=\"title\">I1</span>,<span class=\"title\">I2</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"title\">void</span> <span class=\"title\">I1.Method</span>(<span class=\"title\">string</span> <span class=\"title\">s</span>)&#123;...&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> I2.Method(<span class=\"built_in\">string</span> s)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当以上面的方式来创建类中的方法时，仅能通过接口引用访问该方法，无法通过类的引用来访问，即使是同一个类中的方法也不行</li>\n<li>针对以上问题，可以通过强制转换来进行，举个例子：<code>((I1)MyClass1).Method</code></li>\n</ul>\n",
            "tags": [
                "csharp",
                "csharp图解教程"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E9%9B%86%E5%90%88/",
            "url": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E9%9B%86%E5%90%88/",
            "title": "Csharp读书笔记（六）-枚举与集合",
            "date_published": "2022-02-11T04:02:27.000Z",
            "content_html": "<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><ul>\n<li>枚举只允许几个特定的值</li>\n<li><code>enum</code>数据类型只允许某个数据取某些特定的值<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Computers&#123;</span><br><span class=\"line\">\tComputer1=<span class=\"number\">1</span>,<span class=\"comment\">//不仅可以指定名称，还可以指定值</span></span><br><span class=\"line\">\tComputer2=<span class=\"number\">2</span>,</span><br><span class=\"line\">\tComputer3=<span class=\"number\">3</span>,<span class=\"comment\">//这个逗号可以省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>enum</code>也是一种类型，每一项都可以当作参数传递，如<code>Computers.Computer1</code>这样传递</li>\n<li>枚举中的每一项都必须有名称，但不一定需要指定一个值</li>\n<li>可以使用<code>.ToString()</code>方法来获得任意一项的名称，使用强制转换获得其值</li>\n<li>比如：<code>Computers.Computer1.ToString()</code>得到string<code>Computer1</code>,<code>(int)Computers.Computer1</code>得到int<code>1</code></li>\n<li>也可以把int转换回去，例如<code>Computers computer0=(Computers)3;</code>该代码会创建一个指向<code>Computer3</code>的<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"引用\">引用</a><code>computer0</code>（因为等号右边的数字是3，回到<code>Computers</code>中寻找值3，所对应的项为<code>Computer3</code>)，于是<code>computer0.ToString()</code>获得的就是string<code>Computer3</code>了</li>\n<li>如果没有为项指定值，那么C#会自动按照顺序赋值，第一项为0，以此类推</li>\n<li>可以用<code>:</code>指定所需要的类型，例如<code>enum Computers:long</code>这样就可以为其中的项指定非常大的值了</li>\n</ul>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"列表与数组\"><a href=\"#列表与数组\" class=\"headerlink\" title=\"列表与数组\"></a>列表与数组</h3><ul>\n<li>每个<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E7%BB%84/\" title=\"数组\">数组</a>都有一个长度，它是固定的，需要手动调整长度</li>\n<li>不能直接移动数组的元素</li>\n<li>可以使用集合来存储数据，就可以避免以上两个问题</li>\n<li>常用的集合是<code>List&lt;T&gt;</code>，<code>&lt;T&gt;</code>表示类型，把类型放在尖括号中间</li>\n<li>使用<code>.Add()</code>可以添加集合中的项目</li>\n<li><code>List</code>没有大小限制，它会动态调整大小</li>\n<li><code>List</code>有<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"多态\">多态</a>性，也就是可以添加接口、抽象类、基类等</li>\n</ul>\n<h3 id=\"List的使用\"><a href=\"#List的使用\" class=\"headerlink\" title=\"List的使用\"></a>List的使用</h3><ul>\n<li><code>.Contains()</code>可以检查是否有特定元素，括号内写上需要查找的元素</li>\n<li><code>.IndexOf()</code>可以获取特定元素的索引，括号内写上需要查找的元素</li>\n<li><code>.Remove()</code>可以删除元素，括号内写上需要删除的元素</li>\n<li><code>.RemoveAt()</code>可以删除元素，括号内写上需要删除元素的索引号</li>\n<li><code>List</code>本身也是一个对象</li>\n</ul>\n<h3 id=\"foreach循环\"><a href=\"#foreach循环\" class=\"headerlink\" title=\"foreach循环\"></a><code>foreach</code>循环</h3><ul>\n<li><code>foreach</code>可以对list中每个对象执行语句，<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E7%BB%84/\" title=\"数组\">数组</a>也可以这么用</li>\n<li>注意，使用<code>foreach</code>时不能修改这个集合，也就是不能使用该list对应的<code>.Remove()</code>等方法</li>\n<li><code>.ToList()</code>可以创建副本并赋值给新的变量</li>\n<li>使用foreach就是在使用<code>IEnumerable&lt;T&gt;</code></li>\n<li>以下代码实现的效果完全相同<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> (Duck duck <span class=\"keyword\">in</span> ducks)</span><br><span class=\"line\">\tConsole.WriteLine(duck);</span><br><span class=\"line\"><span class=\"comment\">//上下两种方式实现的效果完全相同</span></span><br><span class=\"line\">IEnumerator&lt;Duck&gt; enumerator = ducks.GetEnumerator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (enumerator.MoveNext())</span><br><span class=\"line\">\tConsole.WriteLine(enumerator.Current);</span><br><span class=\"line\"></span><br><span class=\"line\">IDisposable disposable = enumerator <span class=\"keyword\">as</span> IDisposable;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (disposable != <span class=\"literal\">null</span>) disposable.Dispose();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"集合初始化方法\"><a href=\"#集合初始化方法\" class=\"headerlink\" title=\"集合初始化方法\"></a>集合初始化方法</h3><ul>\n<li>可以用集合初始化方法来提供初始数据项列表</li>\n<li>直接在创建列表后面添加大括号，各个初始项中使用逗号隔开</li>\n<li>可以包含new创建的对象，还可以包含变量</li>\n</ul>\n<h3 id=\"集合的排序\"><a href=\"#集合的排序\" class=\"headerlink\" title=\"集合的排序\"></a>集合的排序</h3><ul>\n<li><code>.Sort()</code>可以使列表中的所有项重新有序排列，它已经知道如何重排大部分类型</li>\n<li>有两种排序方法，分别是<code>CompareTo()</code>和实现<code>IComparer&lt;T&gt;</code></li>\n</ul>\n<h4 id=\"排序1：使用CompareTo-方法\"><a href=\"#排序1：使用CompareTo-方法\" class=\"headerlink\" title=\"排序1：使用CompareTo()方法\"></a>排序1：使用<code>CompareTo()</code>方法</h4><ul>\n<li><code>.Sort()</code>知道如何对实现了<code>IComparable&lt;T&gt;</code><a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"接口\">接口</a>的类排序</li>\n<li>该接口只有一个成员，是<code>CompareTo()</code>方法，传入一个要比较的对象</li>\n<li><code>CompareTo()</code>方法会返回一个int值，该方法传入一个要比较的对象x，它把传入的对象与当前对象y（也就是该方法所在的对象）比较，如果x应排在y后面（也就是x&gt;y）则返回正数，反之则返回负数。如果比较相同，则返回0。（如果你实现了正向排列，想要倒序排列，只需在调换正负数的位置即可）</li>\n<li>实现接口后，直接使用<code>.Sort()</code>即可排序</li>\n</ul>\n<h4 id=\"排序2：新建一个实现了IComparable的类\"><a href=\"#排序2：新建一个实现了IComparable的类\" class=\"headerlink\" title=\"排序2：新建一个实现了IComparable&lt;T&gt;的类\"></a>排序2：新建一个实现了<code>IComparable&lt;T&gt;</code>的类</h4><ul>\n<li>可以向<code>.Sort()</code>传入一个实现了<code>IComparer&lt;T&gt;</code>接口的实例</li>\n<li>该接口有一个<code>Compare()</code>方法，传入两个要比较的对象</li>\n<li><code>Compare()</code>方法会返回一个int值，该方法传入两个要比较的对象（假设它们是x,y），它把传入的两个对象比较，如果x应排在y后面（x&gt;y），则返回正数，反之则返回负数。如果比较相同，则返回0。（如果你实现了正向排列，想要倒序排列，只需在调换正负数的位置即可）</li>\n<li>实现接口后，先实例化这个新比较类，然后调用list对象的<code>.Sort()</code>，把新的实例填到括号内，即可比较</li>\n</ul>\n<h4 id=\"多种排序方式\"><a href=\"#多种排序方式\" class=\"headerlink\" title=\"多种排序方式\"></a>多种排序方式</h4><ul>\n<li>可以用第二种方式写不同的比较类，只要填入不同排序类，就可以以不同的方式排序</li>\n<li>注意，以上两种方法可以共存。共存时，<code>.Sort()</code>括号内可以不写，也可以填入比较类，此时会执行比较类中的方法（不会执行CompareTo）</li>\n<li>也就是说，第二种方式有更大的灵活性！</li>\n</ul>\n<h3 id=\"ToString-方法\"><a href=\"#ToString-方法\" class=\"headerlink\" title=\"ToString()方法\"></a>ToString()方法</h3><ul>\n<li>每一个<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"对象\">对象</a>都有一个ToString()方法，把对象转换为一个字符串</li>\n<li>使用+操作符会自动调用该方法，调试工具中的监视也用到了这个方法</li>\n<li>它默认返回类名，但是我们可以覆盖它，让它返回不同的内容</li>\n</ul>\n<h3 id=\"列表的向上强制转换\"><a href=\"#列表的向上强制转换\" class=\"headerlink\" title=\"列表的向上强制转换\"></a>列表的向上强制转换</h3><ul>\n<li>列表的向上强制转换称作协变</li>\n<li>实现了<code>IEnumerable&lt;T&gt;</code>接口的类才可以向上强制转换</li>\n<li>使用该接口引用即可转换<code>IEnumerable&lt;BaseClass&gt; upcastBaseClasses = subclasses</code>，这里subclasses即子类的列表，这个子类实现了IEnumerable</li>\n<li>强制转换后，可以用<code>AddRange</code>把内容添加到另一个列表中</li>\n</ul>\n<h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h3><ul>\n<li>重载即有多个参数不同的同名方法</li>\n<li>直接写两个同名方法，即可使用重载</li>\n</ul>\n<h3 id=\"IEnumerable\"><a href=\"#IEnumerable\" class=\"headerlink\" title=\"IEnumerable\"></a>IEnumerable</h3><ul>\n<li>这个接口表示实现了任何集合，不止是List或数组</li>\n<li>用于<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E9%9B%86%E5%90%88/\" title=\"强制转换\">强制转换</a>、<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E9%9B%86%E5%90%88/\" title=\"foreach循环\">foreach循环</a>等</li>\n</ul>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><ul>\n<li>字典可以将两个东西关联起来，形成一组</li>\n<li>前一个叫键，后一个叫值</li>\n<li>任何类型都可以！</li>\n<li><code>.Add(key,value)</code>可以添加一个项目</li>\n<li><code>.ContainKey(key)</code>可以返回是否有这个键</li>\n<li><code>dict[key]</code>可以获得键对应的值</li>\n<li><code>.Remove(key)</code>可以移除一项</li>\n<li><code>foreach(string key in myDict.Keys)</code>可以遍历键</li>\n<li><code>.Count()</code>可以获得项目数量</li>\n</ul>\n<h3 id=\"更多集合类型——按顺序处理\"><a href=\"#更多集合类型——按顺序处理\" class=\"headerlink\" title=\"更多集合类型——按顺序处理\"></a>更多集合类型——按顺序处理</h3><ul>\n<li>常用的按照顺序处理的集合是queue和stack</li>\n<li>queue类型表示先处理早提交的对象</li>\n<li>stack则相反，先处理最后提交的对象</li>\n</ul>\n<h4 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h4><ul>\n<li><code>.Enqueue()</code>向queue中添加一项</li>\n<li><code>.Peek()</code>允许查看第一项</li>\n<li><code>.Dequeue()</code>允许取出第一项，将后面的对象上移到空出来的位置</li>\n<li><code>.Count</code>,<code>.Clear()</code>与<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E9%9B%86%E5%90%88/\" title=\"list\">list</a>类似</li>\n</ul>\n<h4 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h4><ul>\n<li>可以推入、弹出对象</li>\n<li>添加时用<code>.Push()</code></li>\n<li>取出时用<code>.Pop()</code></li>\n<li><code>.Peek()</code>类似queue</li>\n</ul>\n<h3 id=\"互相转换\"><a href=\"#互相转换\" class=\"headerlink\" title=\"互相转换\"></a>互相转换</h3><ul>\n<li>list,queue,stack可以相互转换</li>\n<li>比如下面这样做<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue&lt;<span class=\"built_in\">string</span>&gt; myQueue=<span class=\"keyword\">new</span> Queue&lt;<span class=\"built_in\">string</span>&gt;(mystack);</span><br></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "csharp",
                "hfc"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/",
            "url": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/",
            "title": "Csharp读书笔记（五）-接口与抽象类",
            "date_published": "2022-01-26T12:45:53.000Z",
            "content_html": "<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>接口告诉类<strong>必须</strong>实现某些方法和<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B0%81%E8%A3%85/\" title=\"属性\">属性</a></li>\n<li>如果没有实现，编译器会报错</li>\n<li>接口可以定义一个类中必须有的方法，这样一个类只要实现接口，就可以做特定的事情</li>\n<li>使用<code>interface</code>关键字定义接口</li>\n<li>接口不能添加任何<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"字段\">字段</a>，因为它不存储数据（但是可以包含<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B0%81%E8%A3%85/\" title=\"属性\">属性</a>）</li>\n<li>命名规范：接口名称以<code>I</code>开头</li>\n<li>只需要在接口中添加方法名和参数，因为接口不做任何事情</li>\n<li>接口中的所有方法都是抽象方法，不能有方法体 ^bbfa07</li>\n<li>一个类只能继承一个类，但可以实现多个接口 ^018e94</li>\n<li>不可以实例化接口，不过可以引用接口</li>\n<li>接口就像清单，指出一个类可以做些什么事情</li>\n</ul>\n<h3 id=\"为什么使用接口？\"><a href=\"#为什么使用接口？\" class=\"headerlink\" title=\"为什么使用接口？\"></a><em>为什么使用接口？</em></h3><ul>\n<li>接口并不是为了避免重复代码，<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BB%A7%E6%89%BF/\" title=\"继承\">继承</a>才是</li>\n<li>如果有<strong>一件事</strong>，<strong>多个类</strong>都能实现，你需要这样一个类作为<strong>参数</strong>，但<strong>不希望继承</strong>时（比如你觉得根本用不到那些东西，<strong>不想让子类继承基类的方法和属性</strong>），这时你无法用继承中的基类来作为参数，那么使用接口，就可以知道：<strong>只要类实现了这个接口，它就能做这件事，可以作为参数使用，而不必知道它到底是什么类型</strong></li>\n<li>如果有<strong>多件事</strong>，<strong>一个类</strong>能实现它们，这时<strong>无法使用</strong>继承（<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"只能继承一个类\">只能继承一个类</a>），就需要使用接口</li>\n<li>继承只是给类“<strong>分层</strong>”（减少重复），接口则可以给类“<strong>分类</strong>”（可以<strong>规定这个类可以干什么</strong>）</li>\n<li>也就是说，当继承给你的类增加太多“负担”时，就应该考虑使用接口</li>\n<li>举个例子，假设你有一个电器类，很多类都继承了它，比如电脑、电视、冰箱……但是现在你想要用一个可以处理食物的类作为参数（比如面包机、烤箱、微波炉……），这时无法使用继承（因为你只能继承一个类），就需要编写一个可处理食物的接口，把要用到的方法属性放进去，在可处理食物的类中实现这个接口，把参数改成这样一个接口引用，就可以解决这个问题</li>\n<li>C#<strong>拒绝继承多个类</strong>，并通过接口提供<strong>保护</strong>，这是为了<strong>避免二义性</strong></li>\n<li>二义性：当两个类<strong>分别继承一个基类</strong>，并且重写了基类中的同一个方法，这时如果允许继承多个类（这称为多重继承），那么<strong>继承这两个类的子类</strong>调用该方法（假设子类没有重写）时应该调用哪个方法？这就会出现问题：子类<strong>不知道应该调用哪个方法</strong>，因为继承了<strong>两个同名的不同方法</strong></li>\n<li>这也被称作“致命的死亡菱形”（如果[[Csharp&#x2F;Csharp读书笔记&#x2F;Csharp读书笔记（一）-对象与引用#创建类图|画出类图]]，会发现这像一个菱形）</li>\n<li>所以C#<strong>通过接口提供保护</strong>，接口并没有方法体（它不做任何事情），因为它没有方法体，所以一个类可以实现多个接口，即使接口中有同名方法，这个类也<strong>只能实现这一个方法</strong>，避免了二义性</li>\n</ul>\n<h3 id=\"接口引用\"><a href=\"#接口引用\" class=\"headerlink\" title=\"接口引用\"></a>接口引用</h3><ul>\n<li>接口引用与<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"对象引用\">对象引用</a>类似，可以保持一个类不被垃圾回收</li>\n<li>可以移动接口引用，就像移动标签一样</li>\n<li>一个类需要实现这个接口，才能添加该接口引用</li>\n<li>使用接口引用访问类时，<strong>只能</strong>访问该接口引用所<strong>对应的方法和属性</strong> ^46c854</li>\n</ul>\n<h3 id=\"类与接口的强制转换\"><a href=\"#类与接口的强制转换\" class=\"headerlink\" title=\"类与接口的强制转换\"></a>类与接口的强制转换</h3><ul>\n<li>可以使用<code>is</code>关键字来查看一个类是否实现了这个接口</li>\n<li>可以用<code>as</code>关键字来把一个类看成实现了这个接口（前提是使用<code>is</code>找出这个类确实实现了）</li>\n<li>为什么使用as：有时候，C#并不知道一个类实现了一个接口（<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"使用了其他接口引用\">使用了其他接口引用</a>），所以使用is之后还要让C#认为它确实实现了</li>\n<li>举例： ^537c57</li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里仅给出核心代码</span></span><br><span class=\"line\">IComputer[] computers=<span class=\"keyword\">new</span> IComputer[<span class=\"number\">3</span>];<span class=\"comment\">//假设有一个叫做IComputer的接口</span></span><br><span class=\"line\">computers[<span class=\"number\">0</span>]=<span class=\"keyword\">new</span> Windows();<span class=\"comment\">//假设Windows,Mac,Linux类实现了IComputer接口</span></span><br><span class=\"line\">computers[<span class=\"number\">1</span>]=<span class=\"keyword\">new</span> Mac();</span><br><span class=\"line\">computers[<span class=\"number\">2</span>]=<span class=\"keyword\">new</span> Linux();</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i=<span class=\"number\">0</span>;i&lt;computers.Length;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(computers[i] <span class=\"keyword\">is</span> IServer)&#123;</span><br><span class=\"line\"> IServer myserver;<span class=\"comment\">//IServer是一个假设的新接口</span></span><br><span class=\"line\"> myserver=computers[i] <span class=\"keyword\">as</span> IServer;</span><br><span class=\"line\"> <span class=\"comment\">//使用as，就能够让C#把这个对象看成实现了IServer,就可以使用IServer中的方法和属性了</span></span><br><span class=\"line\"> myserver.Run();<span class=\"comment\">//假设IServer中有一个Run()方法，只有使用了as才能够使用</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在上面的例子中，C#知道computers数组中的类都实现了IComputer（因为这是个IComputer接口的数组），所以<strong>只能调用这些类中IComputer接口中包含的方法和属性</strong>（可以把接口看作一个清单，这里<strong>只能调用清单中的内容</strong>），而当使用<code>is</code>关键字找出这个类确实实现了IServer接口时，C#<strong>仍然不认为</strong>它实现了IServer（因为你根本没有告诉它这么认为，只是让他<strong>检查</strong>了这个“清单”是否与类匹配，这是<code>is</code>关键字所做的），所以你需要使用<code>as</code>关键字，这样C#就会认为<strong>它确实实现了IServer</strong>，就<strong>可以（且只能）调用IServer中的方法、属性了</strong></li>\n<li>由子类代替基类时，这称为向上强制转换</li>\n<li>由基类代替子类时，这叫做向下强制转换</li>\n<li>接口也可以这么做（上面的<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"举例\">举例</a>就是一个接口向下强制转换的例子）</li>\n</ul>\n<h3 id=\"接口的继承\"><a href=\"#接口的继承\" class=\"headerlink\" title=\"接口的继承\"></a>接口的继承</h3><ul>\n<li>接口可以继承其他接口</li>\n<li>实现继承其他接口的接口时，<strong>必须</strong>实现<strong>所有</strong>继承的接口</li>\n</ul>\n<h3 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h3><ul>\n<li>public表示任何其他类都可以访问</li>\n<li>private表示只有该类中的成员及该类的<strong>其他实例</strong>可以访问</li>\n<li>protected表示对于该类的其他成员来说相当于private，而对于子类来说是public，也就是说子类成员可以访问子类成员及任何基类成员（注意：基类声明为protected后，无需使用base也可以访问基类中的公共类型）</li>\n<li>internal表示只能从程序集或子类访问</li>\n<li>sealed表示不能继承该类</li>\n</ul>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>抽象类不能实例化</li>\n<li>有时候，你想在一个类中完成一部分代码，在子类中再完成其余部分，于是基类根本不应该被实例化（它并不能工作——因为你没有完成它），这时应该使用抽象类，防止你不小心创建了本不应该创建的实例</li>\n<li>比如说，一个方法需要一个<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"字段\">字段</a>来计算，但是在基类中不想设置它的值，想在子类中设置，这时基类是不完整的，它无法计算，所以设置为抽象类，防止误实例化</li>\n<li>可以在抽象类中添加抽象方法，也可以有具体方法，这与<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"接口\">接口</a>不同</li>\n</ul>\n<h3 id=\"面向对象的设计原则\"><a href=\"#面向对象的设计原则\" class=\"headerlink\" title=\"面向对象的设计原则\"></a>面向对象的设计原则</h3><ul>\n<li><a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BB%A7%E6%89%BF/\" title=\"继承\">继承</a>：一个类或一个接口继承另一个</li>\n<li>抽象：建立一个类模型，首先时比较一般的类，然后继承的是更特殊的类，也就是由一般（基类）到特殊（子类）的过程</li>\n<li><a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B0%81%E8%A3%85/\" title=\"封装\">封装</a>：创建一个对象，使用私有字段在内部记录其状态，通过公共属性、方法使其他类只能使用需要的数据以防止错误</li>\n<li>多态：将一个对象用于需要其他对象的方法或语句，比如<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/\" title=\"类与接口的强制转换\">类与接口的强制转换</a></li>\n</ul>\n",
            "tags": [
                "csharp",
                "hfc"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BB%A7%E6%89%BF/",
            "url": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BB%A7%E6%89%BF/",
            "title": "Csharp读书笔记（四）-继承",
            "date_published": "2022-01-24T12:45:39.000Z",
            "content_html": "<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>继承可以构建彼此关联且有共同行为的类</li>\n<li>被继承的叫做基类</li>\n<li>继承别人的叫做子类</li>\n<li>类图中，箭头由子类指向基类</li>\n<li>沿着类图上行，可以发现类的相同特征越少</li>\n<li>沿着类图下行，可以发现类的相同特征越多</li>\n<li>这就好像生物的分类——界门科目纲属种</li>\n<li>使用冒号可以继承一个基类</li>\n<li>一个类只允许继承一个类，这是一种保护</li>\n</ul>\n<h3 id=\"合并两个类\"><a href=\"#合并两个类\" class=\"headerlink\" title=\"合并两个类\"></a>合并两个类</h3><ol>\n<li>首先<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"创建类图\">创建类图</a></li>\n<li>找出两个类相同的字段与方法</li>\n<li>把相同的放到一个基类中去</li>\n<li>把不同的放在子类，要[[#覆盖]]的也需要写入</li>\n<li>画上子类指向基类的箭头</li>\n</ol>\n<h3 id=\"覆盖\"><a href=\"#覆盖\" class=\"headerlink\" title=\"覆盖\"></a>覆盖</h3><ul>\n<li>在子类中，可以覆盖基类的方法</li>\n<li>举例，狗和猫都是动物，但是叫声不同，创建这样的类时，可以把Animal作为基类，Dog&#x2F;Cat作为子类，在子类中覆盖Animal类的发出叫声的方法</li>\n<li>执行顺序：对于C#，执行方法时总是先从基类中寻找，如果在该子类中找不到，会沿着类图上行，一个个寻找，直到找到对应的方法 ^7e9264</li>\n<li>被覆盖的方法添加<code>virtual</code>关键字</li>\n<li>要覆盖别人的方法添加<code>override</code>关键字</li>\n</ul>\n<h3 id=\"隐藏的方法\"><a href=\"#隐藏的方法\" class=\"headerlink\" title=\"隐藏的方法\"></a>隐藏的方法</h3><ul>\n<li>如果不添加这些关键字，则不会覆盖方法，而是隐藏了基类中的方法</li>\n<li>隐藏会导致产生两个同名的方法 ^b0994f</li>\n<li>在隐藏方法时，需要为子类中的方法添加<code>new</code>关键字</li>\n<li>如果隐藏了方法，调用时会根据<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"引用\">引用</a>来执行，也就是调用对应引用类型的方法</li>\n<li>如果调用了一个<strong>子类引用</strong>中该子类<strong>对应基类</strong>中的方法，且<strong>该方法</strong>中调用了另一个<strong>隐藏的方法</strong>（有两个<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BB%A7%E6%89%BF/\" title=\"同名方法\">同名方法</a>），则会执行<strong>对应基类</strong>中的隐藏方法</li>\n</ul>\n<h3 id=\"继承的用法\"><a href=\"#继承的用法\" class=\"headerlink\" title=\"继承的用法\"></a>继承的用法</h3><ul>\n<li>对于传递一个类的参数，如果该参数需要一个基类，则不仅可以传递该基类，还可以传递它的子类（任何一个都可以）</li>\n<li>传递后，只能使用对应传递的类中的内容</li>\n<li>比如传递一个基类，就不能使用它的子类的内容</li>\n<li>传递一个子类，也<strong>不能</strong>使用<strong>对应基类</strong>的<strong>其他子类</strong>中的内容</li>\n<li>子类可以使用<code>base</code>关键字访问基类中的方法，即使它们被覆盖了</li>\n</ul>\n<h3 id=\"继承中的\"><a href=\"#继承中的\" class=\"headerlink\" title=\"继承中的\"></a>继承中的<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B0%81%E8%A3%85/\" title=\"构造函数\">构造函数</a></h3><ul>\n<li>如果基类中有带参数的构造函数，则在子类中也必须调用其中一个</li>\n<li>但是，子类的构造函数与基类的构造函数可以有不同参数</li>\n<li>构造函数执行时，会从基类开始，沿着类图下行依次执行（这和<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BB%A7%E6%89%BF/\" title=\"覆盖的执行顺序\">覆盖的执行顺序</a>正好相反）</li>\n<li>举例</li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyBase</span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyBase</span>(<span class=\"params\"><span class=\"built_in\">int</span> number1</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> Console.WriteLine(number1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MySub</span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MySub</span>(<span class=\"params\"><span class=\"built_in\">int</span> number1,<span class=\"built_in\">int</span> number2</span>):<span class=\"title\">base</span>(<span class=\"params\">number1</span>)</span>&#123;</span><br><span class=\"line\"> Console.WriteLine(number2);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//output: number1 number2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>让类尽可能减少重叠，这是一个重要的设计原则，称作关注点分离</li>\n<li><code>String.IsNullOrEmpty()</code>可以检测一个字符串是否为空（即<code>&quot;&quot;</code>）或<code>null</code></li>\n</ul>\n",
            "tags": [
                "csharp",
                "hfc"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B0%81%E8%A3%85/",
            "url": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B0%81%E8%A3%85/",
            "title": "Csharp读书笔记（三）-封装",
            "date_published": "2022-01-23T12:45:22.000Z",
            "content_html": "<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><ul>\n<li>封装保证类中一些数据是私有的</li>\n<li>私有字段、方法只能在类内部访问，使用关键字<code>private</code></li>\n<li>封装可以避免不必要的错误</li>\n</ul>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><ul>\n<li>属性对于其他对象来说就是<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"字段\">字段</a></li>\n<li>可以通过属性获取或设置一个后备字段</li>\n<li>属性首字母大写，后备字段应小写</li>\n<li><strong>属性的好处：在获取或设置时可以执行一些语句（比如设置一些有关的字段），防止直接更改字段导致逻辑计算错误</strong></li>\n<li>获取<code>get</code></li>\n<li>设置<code>set</code></li>\n<li>每个<code>set</code>都有一个名为<code>value</code>的参数，获取的是设置的值</li>\n<li>可以只设置<code>get</code>或<code>set</code>中的一个</li>\n<li>举例：</li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> numberOfComputers;<span class=\"comment\">//这是一个后备字段</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> displays;<span class=\"comment\">//这是另一个字段</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> NumberOfComputers<span class=\"comment\">//这是一个属性</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">get</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> numberOfComputers;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">set</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  numberOfComputers = <span class=\"keyword\">value</span>;<span class=\"comment\">//设置后备字段</span></span><br><span class=\"line\">  displays = <span class=\"keyword\">value</span>*<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">/*举例，每台电脑需要2个显示器，</span></span><br><span class=\"line\"><span class=\"comment\">  *这样封装可以防止直接从外部</span></span><br><span class=\"line\"><span class=\"comment\">  *修改displays，</span></span><br><span class=\"line\"><span class=\"comment\">  *而外部代码可能发生错误导致dispalys不是2倍</span></span><br><span class=\"line\"><span class=\"comment\">  *这就避免了不必要的错误</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在窗体应用执行<code>Console.WriteLine()</code>时，输出显示在<code>output</code>窗口</li>\n<li>输入<code>prop</code>，再按下tab，会向代码中添加一个自动属性</li>\n</ul>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li>构造函数会在类创建时执行</li>\n<li>构造函数没有返回值</li>\n<li>添加构造函数时，需要添加一个与类同名的方法，但是没有返回值</li>\n<li>构造函数可以用来在创建<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"实例\">实例</a>时为私有变量指定值</li>\n<li>当然也可以做更多事情</li>\n</ul>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>方法的第一行包含存取修饰符、返回值、名字和参数，这些称之为签名</li>\n<li>属性也有签名</li>\n</ul>\n",
            "tags": [
                "csharp",
                "hfc"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E7%BB%84/",
            "url": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E7%BB%84/",
            "title": "Csharp读书笔记（二）-数组",
            "date_published": "2022-01-22T12:45:08.000Z",
            "content_html": "<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ul>\n<li><p>数组是一组变量，可以存储和修改多个数据</p>\n</li>\n<li><p>创建数组时，需要指定类型、名称和元素数量</p>\n</li>\n<li><p>可以为<a href=\"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/\" title=\"引用\">引用</a>创建数组，但是创建时只会创建引用变量，不会创建实例</p>\n</li>\n<li><p>必须分别为每一个对象创建实例</p>\n</li>\n<li><p>数组的索引是从0开始的</p>\n</li>\n<li><p>比如，创建一个元素数量为6的int数组，<code>int[] numbers=new int[6]</code>，此时访问<code>numbers[5]</code>，这时获取的元素为第6个</p>\n</li>\n<li><p><code>Random</code>类可以随机生成数字</p>\n</li>\n<li><p>使用时，先创建实例，再使用<code>Next()</code>方法，举例：调用<code>GetRandom()</code>时，以下代码会返回一个9到100间的随机整数</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Random Randomizer;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">GetRandom</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>(Randomizer.Next(<span class=\"number\">9</span>,<span class=\"number\">100</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对价格使用decimal类型时，要在值后面加上M</p>\n</li>\n</ul>\n",
            "tags": [
                "csharp",
                "hfc"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/",
            "url": "https://blog.samhou.top/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/",
            "title": "Csharp读书笔记（一）-对象与引用",
            "date_published": "2022-01-21T12:44:44.000Z",
            "content_html": "<p>这个系列是head first csharp书籍的读书笔记，总结提炼了一些C#的核心内容，以及自己的个人理解。</p>\n<h2 id=\"程序从哪里来\"><a href=\"#程序从哪里来\" class=\"headerlink\" title=\"程序从哪里来\"></a>程序从哪里来</h2><ul>\n<li>IDE是一种方便的文件编辑器</li>\n<li>.NET提供很多工具来帮助你完成任务</li>\n<li>程序在CLR中运行</li>\n<li>using语句让你可以使用其他命名空间中的类</li>\n<li>命名空间包含类，类包含方法，方法由语句组成</li>\n<li>方法前的类型指出了这个方法的返回值，方法后的括号中包含参数</li>\n</ul>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><ul>\n<li>由一个类创建新对象时，称为这个类的一个实例 ^be690f</li>\n<li>使用new关键字创建实例</li>\n<li>静态类不用创建实例，但其他类需要创建实例才能使用</li>\n<li>可以在类中包含静态方法，使用它们时不用创建实例</li>\n<li>实例使用字段来跟踪其状态 ^52e61c</li>\n<li>每个实例都会有自己的变量副本</li>\n<li>创建对象时，会放在内存中的一个部分，称作堆</li>\n<li>类图可以帮助你组织类</li>\n</ul>\n<h3 id=\"创建类图\"><a href=\"#创建类图\" class=\"headerlink\" title=\"创建类图\"></a>创建类图</h3><ol>\n<li>画一个矩形方框</li>\n<li>在顶部写出字段</li>\n<li>画一条横线</li>\n<li>在下方写出方法</li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ul>\n<li>对象的一个引用叫做引用变量</li>\n<li>引用像标签，可以通过标签找到对象</li>\n<li>一个对象可以有多个引用，就像你可以给一个瓶子贴多个标签</li>\n<li>引用可以移动</li>\n<li>一个没有引用的对象会被垃圾回收</li>\n<li>移动引用：</li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myclass class1=<span class=\"keyword\">new</span> myclass();</span><br><span class=\"line\">myclass class2=<span class=\"keyword\">new</span> myclass();</span><br><span class=\"line\">class1=class2;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>这样做把class2指向的myclass实例“赋值”给class1这个引用，<br>相当于把class2指向的myclass实例贴上了class1的标签，<br>也就是把class1的引用移动到class2上面，<br>这样原来class1指向的对象会被垃圾回收！  </p>\n<hr>\n",
            "tags": [
                "csharp",
                "hfc"
            ]
        }
    ]
}