{
    "version": "https://jsonfeed.org/version/1",
    "title": "SamHou's blog • All posts by \"windows\" tag",
    "description": "SamHou 的一个博客，有技术文章，小说和生活学习方法分享。包含 C#、html、css、NAS、windows 的技术博客文章，以及大量二次创作小说和原创作品。",
    "home_page_url": "https://blog.samhou.top",
    "items": [
        {
            "id": "https://blog.samhou.top/say-goodbye-to-hyper-v/",
            "url": "https://blog.samhou.top/say-goodbye-to-hyper-v/",
            "title": "和 Hyper-V 说再见——完全迁移&卸载指南",
            "date_published": "2024-11-22T11:11:57.000Z",
            "content_html": "<p>花了点时间，终于摆脱了 Hyper-V 这个恶心的东西，用上了 VirturalBox，遂记录在此。</p>\n<h2 id=\"转换磁盘\"><a href=\"#转换磁盘\" class=\"headerlink\" title=\"转换磁盘\"></a>转换磁盘</h2><p>hyper-v 和 virtualbox 的虚拟硬盘不是同一个格式，需要进行转换。同时，还要进行合并操作。这里已经有大佬写过了，看<a href=\"https://blog.dowhat.top/archives/1340\">这个</a>吧。</p>\n<p>转换成功后，创建新的虚拟机，导入磁盘。</p>\n<p><img src=\"https://img.samhou.top/1731768839789.png\" alt=\"选择虚拟硬盘\"></p>\n<p>调整下 vm 的内存和 cpu，启动然后开机，搞定。</p>\n<p><strong>注意：你的虚拟电脑可能卡到爆炸，因为 virtualbox 使用 hyper-v 时性能很低，需要完全关闭它才能发挥全部性能。如果实在卡到无法操作，请先<a href=\"#%E5%85%B3%E9%97%AD-hyper-v\">关闭 hyper-v</a>。</strong></p>\n<p><strong>注意：由于环境变化，你需要重新在虚拟机中进行某些操作，例如登录各种软件，以及重新激活 Windows。</strong></p>\n<p><del>一个小小的提示：请不要运行 <code>irm https://get.activated.win | iex</code> 参见<a href=\"https://github.com/massgravel/Microsoft-Activation-Scripts\">此处</a></del></p>\n<h2 id=\"关闭-hyper-v\"><a href=\"#关闭-hyper-v\" class=\"headerlink\" title=\"关闭 hyper-v\"></a>关闭 hyper-v</h2><p>因为<a href=\"https://forums.virtualbox.org/viewtopic.php?f=25&t=99390\">某些原因</a>，hyper-v 和 virtualbox 一起用实在太卡。你也许注意到了，右下角的海龟图标。<img src=\"https://www.virtualbox.org/export/80012/vbox/trunk/src/VBox/Frontends/VirtualBox/images/vm_execution_engine_native_api_16px.png\">这表明它在运行，但非常缓慢。是时候关闭没用的 hyper-v 了！</p>\n<h3 id=\"卸载功能\"><a href=\"#卸载功能\" class=\"headerlink\" title=\"卸载功能\"></a>卸载功能</h3><p>win+r 输入 control 打开控制面板，导航到程序-程序和功能-启用或关闭 Windows 功能，然后取消勾选 hyper-v，重启。</p>\n<p>好的，看起来我们已经摆脱了它，然而……</p>\n<p>还是海龟图标！</p>\n<p>这是因为，某些服务依赖于 hyper-v。你需要关闭它们。</p>\n<h3 id=\"关闭虚拟化安全\"><a href=\"#关闭虚拟化安全\" class=\"headerlink\" title=\"关闭虚拟化安全\"></a>关闭虚拟化安全</h3><p>win+r 输入 gpedit.msc，打开组策略，导航到本地计算机策略-计算机配置-管理模板-系统-Device Guard-打开基于虚拟化的安全，设置为“已禁用”。</p>\n<p>重启电脑，然后打开设置-隐私和安全性-Windows 安全中心-打开 Windows 安全中心-主页-设备安全性-内核隔离-内核隔离详细信息-内存完整性-关。</p>\n<p><img src=\"https://img.samhou.top/1732273948535.png\" alt=\"内核隔离\"></p>\n<p>重启设备。</p>\n<p>再打开 VirtualBox，谢天谢地，它好了。<img src=\"https://img.samhou.top/1732274115722.png\"></p>\n",
            "tags": [
                "windows",
                "Hyper-V",
                "卸载"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E7%84%A6%E7%82%B9(%E5%89%8D%E5%8F%B0%E7%AA%97%E5%8F%A3)/",
            "url": "https://blog.samhou.top/Csharp%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E7%84%A6%E7%82%B9(%E5%89%8D%E5%8F%B0%E7%AA%97%E5%8F%A3)/",
            "title": "Csharp强制设置系统焦点(前台窗口)",
            "date_published": "2023-01-27T01:01:20.000Z",
            "content_html": "<h2 id=\"系统焦点\"><a href=\"#系统焦点\" class=\"headerlink\" title=\"系统焦点\"></a>系统焦点</h2><p>在Windows中，系统的焦点就是当前处于前台的窗口。通过设置焦点，可以控制用户正在使用的应用程序。这里以winform应用为例。</p>\n<h2 id=\"Api调用\"><a href=\"#Api调用\" class=\"headerlink\" title=\"Api调用\"></a>Api调用</h2><p>C#需要调用Win32 Api才可以控制焦点，这里用到的是user32.dll中的SetForegroundWindow()函数</p>\n<p>在微软提供的文档中[1]，可以看到C++里的用法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">SetForegroundWindow</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  [in] HWND hWnd<span class=\"comment\">//窗口句柄</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>C#里没有HWND类型，与之对应的是IntPtr类型，所以可以这样导入Api[2]</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Runtime.InteropServices;<span class=\"comment\">//这是调用所必须的</span></span><br><span class=\"line\">[<span class=\"meta\">DllImport(<span class=\"string\">&quot;user32.dll&quot;</span>)</span>]<span class=\"comment\">//调用dll</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"built_in\">bool</span> <span class=\"title\">SetForegroundWindow</span>(<span class=\"params\">IntPtr handle</span>)</span>;<span class=\"comment\">//这个函数签名必须和文档一模一样</span></span><br></pre></td></tr></table></figure>\n\n<p>下面来调用导入的内容（以设置edge浏览器为例子）</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process[] processes = Process.GetProcessesByName(<span class=\"string\">&quot;msedge&quot;</span>);<span class=\"comment\">//查找edge浏览器进程</span></span><br><span class=\"line\">IntPtr handle = processes[<span class=\"number\">0</span>].MainWindowHandle;<span class=\"comment\">//获取主窗口句柄</span></span><br><span class=\"line\">SetForegroundWindow(handle);</span><br></pre></td></tr></table></figure>\n\n<p>但是，文档上指出这样设置需要满足几个条件中的任意一个：</p>\n<blockquote>\n<p>此过程是前台进程。&#x2F;进程由前台进程启动。&#x2F;进程收到了最后一个输入事件。&#x2F;没有前台进程。&#x2F;正在调试该过程。&#x2F;前台进程不是新式应用程序或“开始”屏幕。&#x2F;前台未锁定， (请参阅 <a href=\"https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-locksetforegroundwindow\">LockSetForegroundWindow</a>) 。&#x2F;前台锁定超时已过期， (在 <a href=\"https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa\">SystemParametersInfo</a>) 中看到<strong>SPI_GETFOREGROUNDLOCKTIMEOUT</strong>。&#x2F;没有活动菜单。&#x2F;当用户使用另一个窗口时，应用程序无法强制将窗口强制到前台。 相反，Windows 会闪烁窗口的任务栏按钮以通知用户。</p>\n</blockquote>\n<p>这样就不能说是强制设置了（注意，调试程序时系统允许强制设置，但只要离开调试器，就不行了），所以下面给出一个特别的方法。</p>\n<h2 id=\"强制设置\"><a href=\"#强制设置\" class=\"headerlink\" title=\"强制设置\"></a>强制设置</h2><p>Windows中，只要是新启动的窗口，总是能够获得系统的焦点。所以只要让程序重新启动，就能拿到焦点，变成前台进程，此时就可以设置焦点，达到强制的效果。</p>\n<p>这里还用到了另一个Api <code>GetForegroundWindow()</code>用于获取当前焦点[3]，调用方式同上，此处不再解释。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">DllImport(<span class=\"string\">&quot;user32.dll&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> IntPtr <span class=\"title\">GetForegroundWindow</span>()</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">Process[] processes = Process.GetProcessesByName(<span class=\"string\">&quot;msedge&quot;</span>);</span><br><span class=\"line\">IntPtr handle = processes[<span class=\"number\">0</span>].MainWindowHandle;</span><br><span class=\"line\">SetForegroundWindow(handle);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (handle!=GetForegroundWindow())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     Process.Start(Application.ExecutablePath);</span><br><span class=\"line\">     Environment.Exit(<span class=\"number\">0</span>);<span class=\"comment\">//重启</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，该方法仅30%成功率，若连续10次重启仍未获得焦点，建议放弃(</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] <a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow\">https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow</a></p>\n<p>[2] <a href=\"https://www.cnblogs.com/code1992/p/5965997.html\">https://www.cnblogs.com/code1992/p/5965997.html</a></p>\n<p>[3] <a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getforegroundwindow\">https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getforegroundwindow</a></p>\n",
            "tags": [
                "csharp",
                "窗口控制",
                "焦点",
                "windows"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp-winform%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E8%AF%A6%E8%A7%A3/",
            "url": "https://blog.samhou.top/Csharp-winform%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E8%AF%A6%E8%A7%A3/",
            "title": "Csharp-winform窗口拖动详解",
            "date_published": "2022-05-29T08:05:02.000Z",
            "content_html": "<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><ul>\n<li>首先，在设计器里双击增加以下三个方法，然后填入以下代码<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">private</span> Point mouseLocation;<span class=\"comment\">//表示鼠标对于窗口左上角的坐标的负数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> isDragging;<span class=\"comment\">//标识鼠标是否按下</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">MainWindow_MouseDown</span>(<span class=\"params\"><span class=\"built_in\">object</span> sender, MouseEventArgs e</span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.Button == MouseButtons.Left)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              mouseLocation = <span class=\"keyword\">new</span> Point(-e.X, -e.Y);</span><br><span class=\"line\">              <span class=\"comment\">//表示鼠标当前位置相对于窗口左上角的坐标，</span></span><br><span class=\"line\">              <span class=\"comment\">//并取负数,这里的e是参数，</span></span><br><span class=\"line\">              <span class=\"comment\">//可以获取鼠标位置</span></span><br><span class=\"line\">              isDragging = <span class=\"literal\">true</span>;<span class=\"comment\">//标识鼠标已经按下</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">MainWindow_MouseMove</span>(<span class=\"params\"><span class=\"built_in\">object</span> sender, MouseEventArgs e</span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (isDragging)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              Point newMouseLocation = MousePosition;</span><br><span class=\"line\">              <span class=\"comment\">//获取鼠标当前位置</span></span><br><span class=\"line\">              newMouseLocation.Offset(mouseLocation.X, mouseLocation.Y);</span><br><span class=\"line\">              <span class=\"comment\">//用鼠标当前位置加上鼠标相较于窗体左上角的</span></span><br><span class=\"line\">              <span class=\"comment\">//坐标的负数，也就获取到了新的窗体左上角位置</span></span><br><span class=\"line\">              Location = newMouseLocation;<span class=\"comment\">//设置新的窗体左上角位置</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">MainWindow_MouseUp</span>(<span class=\"params\"><span class=\"built_in\">object</span> sender, MouseEventArgs e</span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (isDragging)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              isDragging = <span class=\"literal\">false</span>;<span class=\"comment\">//鼠标已抬起，标识为false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h2><ul>\n<li>鼠标在窗体上按下时，窗体跟随鼠标，鼠标抬起时，窗体停止移动</li>\n<li>窗体的Location属性为<strong>左上角</strong>的坐标</li>\n<li>为了实现拖动，需要获取2个坐标：鼠标相较于窗体左上角的位置，以及鼠标现在的坐标</li>\n<li>举个例子：按下鼠标时，鼠标位置(300,400)，获取鼠标相较于窗体左上角位置为(150,100)，那么此时窗体位置是(150,300)，鼠标移动到(300,401)，那么此时窗体位置应该是(150,301)。也就是说，新的窗体位置就是新的鼠标位置减去一开始鼠标相较于窗体左上角位置</li>\n<li>调用.OffSet()，就是把前面的坐标加上括号里的坐标，比如上面的例子，newMouseLocation是(300,401)，mouseLocation把鼠标相较于窗体左上角位置作为负数存储，mouseLocation是(-150,-100)，那么新的newMouseLocation就是(150,301)了~</li>\n</ul>\n",
            "tags": [
                "winform",
                "windows"
            ]
        },
        {
            "id": "https://blog.samhou.top/windowsUAC%E8%B7%B3%E8%BF%87%E6%95%99%E7%A8%8B/",
            "url": "https://blog.samhou.top/windowsUAC%E8%B7%B3%E8%BF%87%E6%95%99%E7%A8%8B/",
            "title": "windows UAC跳过教程",
            "date_published": "2021-10-04T16:00:00.000Z",
            "content_html": "<h1 id=\"什么是UAC\"><a href=\"#什么是UAC\" class=\"headerlink\" title=\"什么是UAC\"></a>什么是UAC</h1><p>安装软件时、运行部分程序时弹出的窗口就是UAC，比如下面这个以管理员权限运行的记事本<br><img src=\"https://z3.ax1x.com/2021/10/07/5p3kxf.png\" alt=\"管理员运行记事本\"></p>\n<p>有时候，运行一些程序可能需要管理员权限，比如某些电脑清理软件。</p>\n<h1 id=\"第一种方法：直接关闭UAC\"><a href=\"#第一种方法：直接关闭UAC\" class=\"headerlink\" title=\"第一种方法：直接关闭UAC\"></a>第一种方法：直接关闭UAC</h1><ol>\n<li>打开控制面板-系统和安全-安全和维护</li>\n<li>在用户账户控制那里点击更改设置</li>\n<li>下拉到“从不通知”</li>\n</ol>\n<h1 id=\"第二种方法：使用任务计划程序\"><a href=\"#第二种方法：使用任务计划程序\" class=\"headerlink\" title=\"第二种方法：使用任务计划程序\"></a>第二种方法：使用任务计划程序</h1><ol>\n<li>右键windows图标</li>\n<li>选择计算机管理</li>\n<li>选择左侧的任务计划程序-任务计划程序库</li>\n<li>点击右侧“创建任务…”</li>\n<li>名称随便填，勾选<img src=\"https://z3.ax1x.com/2021/10/07/5p3iGt.png\" alt=\"最高权限运行\"></li>\n<li>操作一栏中选择新建，弹出这么个窗口：<br><img src=\"https://z3.ax1x.com/2021/10/07/5pIiY4.png\" alt=\"新建操作\"></li>\n<li>这里就选择启动程序，点浏览，选择要跳过UAC的程序，确定保存</li>\n<li>根据需要设定剩下的条件、设置、触发器</li>\n<li>如果需要开机启动，请选择<strong>登录时</strong>，不要选择<del>启动时</del>（因为要登陆再启动程序）</li>\n<li>设置完成，现在添加一个对于新建的任务的快捷方式：在电脑桌面上右键新建-快捷方式，位置一栏输入<code>SCHTASKS /RUN /TN 任务名称</code>，把任务名称改为在第5步中创建的名称</li>\n<li>现在建立了快捷方式，双击桌面上的图标即可跳过UAC运行软件~</li>\n</ol>\n",
            "tags": [
                "windows",
                "UAC"
            ]
        },
        {
            "id": "https://blog.samhou.top/%E4%BD%BF%E7%94%A8windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/",
            "url": "https://blog.samhou.top/%E4%BD%BF%E7%94%A8windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/",
            "title": "使用windows计划任务实现插入移动硬盘自动运行程序",
            "date_published": "2021-09-04T16:00:00.000Z",
            "content_html": "<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>在系统计划任务中，有一个“发生事件时”的触发器。这让插入移动硬盘自动运行程序成为了可能。所以只要找到插入硬盘时触发的系统事件，即可实现。在事件查看器中，通过筛选，我发现插入硬盘时，触发了来源为DistributedCOM的警告事件，ID为10016。</p>\n<h2 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h2><ol>\n<li>插入移动硬盘</li>\n<li>右键开始菜单图标，选择计算机管理，选择系统工具-事件查看器-windows日志-系统，找到刚刚插入硬盘发生的DistributedCOM事件，如下图<br><img src=\"https://z3.ax1x.com/2021/10/07/5p3FRP.png\" alt=\"DistributedCOM\"></li>\n<li>右键这个警告事件，选择将“任务附加到此事件”，通过这个向导即可创建一个自动任务。</li>\n</ol>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><p>这个功能用途很多，比如插入后自动运行备份程序，关键看需求。</p>\n",
            "tags": [
                "windows",
                "任务计划程序"
            ]
        }
    ]
}