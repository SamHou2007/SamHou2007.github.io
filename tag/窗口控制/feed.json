{
    "version": "https://jsonfeed.org/version/1",
    "title": "SamHou's blog • All posts by \"窗口控制\" tag",
    "description": "A blog",
    "home_page_url": "https://blog.samhou.top",
    "items": [
        {
            "id": "https://blog.samhou.top/Winform%20Csharp%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/",
            "url": "https://blog.samhou.top/Winform%20Csharp%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/",
            "title": "Winform C#多显示器窗口控制详解",
            "date_published": "2023-12-08T07:12:38.000Z",
            "content_html": "<p>写Winform程序的时候，有将一个窗口放置到特定的显示器，并且全屏的需求。于是借此机会，好好研究了一番这个Screen类[1]，总结了一些方法。</p>\n<h2 id=\"Windows的窗口逻辑\"><a href=\"#Windows的窗口逻辑\" class=\"headerlink\" title=\"Windows的窗口逻辑\"></a>Windows的窗口逻辑</h2><p>首先我们需要知道窗口定位的逻辑。以2个窗口为例，下面的图片展示了显示器和坐标的对应关系。注意，使用深色模式可能看不清，可以点击上方的切换按钮切换为浅色。</p>\n<p><img src=\"https://img.samhou.top/1702026494796.png\" alt=\"显示器与坐标对应\" srcset=\"data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E\" data-src=\"https://img.samhou.top/1702026494796.png\" class=\"lozad post-image\"></p>\n<p>可以看到，连接多个显示器后，每个显示器的每个点都有一个唯一的坐标。我们要做的，就是把Form的坐标设置到显示器上面去。</p>\n<h2 id=\"获取显示器列表\"><a href=\"#获取显示器列表\" class=\"headerlink\" title=\"获取显示器列表\"></a>获取显示器列表</h2><p>首先确保引用了<code>using System.Windows.Forms;</code>，这样才有Screen类可以用。</p>\n<p>文档指出，可以用<code>Screen.AllScreens</code>获取所有显示器的数组。那么这个里面有什么呢？我们来看看文档是怎么说的：</p>\n<blockquote>\n<p>Property Value<br><a href=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.screen?view=windowsdesktop-8.0\">Screen</a>[]<br>An array of type <a href=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.screen?view=windowsdesktop-8.0\">Screen</a>, containing all displays on the system.</p>\n</blockquote>\n<p>也就是说，返回的数组是个Screen数组。数组里面每一个元素都是个Screen对象，分别对应用户的每个显示设备。因此，我们可以通过这些对象来访问每个显示器。比如：</p>\n<pre class=\"highlight\"><span class=\"line\">Screen scr1=Screen.AllScreens[<span class=\"number\">0</span>] <span class=\"comment\">//获取第1个显示器</span></span><br><span class=\"line\">Screen scr2=Screen.AllScreens[<span class=\"number\">1</span>]<span class=\"comment\">//第二个显示器</span></span><br></pre>\n\n<h2 id=\"设置窗口位置\"><a href=\"#设置窗口位置\" class=\"headerlink\" title=\"设置窗口位置\"></a>设置窗口位置</h2><p>为了设定窗口位置，我们需要知道一个显示器左上角对应的坐标，这样才可以把窗口放进去。</p>\n<p>比如，以下代码可以设置Form位置为第2个显示器的左上角，然后设置窗口覆盖全屏幕（包括任务栏：</p>\n<pre class=\"highlight\"><span class=\"line\">Location = Screen.AllScreens[<span class=\"number\">1</span>].Bounds.Location;<span class=\"comment\">//设定目标坐标，结合上面的图片，这里是（1920，28）</span></span><br><span class=\"line\">Width = Screen.AllScreens[<span class=\"number\">1</span>].Bounds.Width;<span class=\"comment\">//设定窗口的宽度</span></span><br><span class=\"line\">Height = Screen.AllScreens[<span class=\"number\">1</span>].Bounds.Height;<span class=\"comment\">//设定窗口高度</span></span><br></pre>\n\n<p>但大部分情况下，我们只需要覆盖任务栏之上的部分，因此稍作修改：</p>\n<pre class=\"highlight\"><span class=\"line\">Location = Screen.AllScreens[<span class=\"number\">1</span>].WorkingArea.Location;<span class=\"comment\">//设定目标显示器</span></span><br><span class=\"line\">Width = Screen.AllScreens[<span class=\"number\">1</span>].WorkingArea.Width;<span class=\"comment\">//设定窗口的宽度</span></span><br><span class=\"line\">Height = Screen.AllScreens[<span class=\"number\">1</span>].WorkingArea.Height;<span class=\"comment\">//设定窗口高度</span></span><br></pre>\n\n<p>注意到了吗？这里我们用的是<code>WorkingArea</code>来获取长宽高，以及位置。<code>WorkingArea</code>不包括任务栏，所以高度较少，这两种需要看情况使用。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>[1] <a href=\"https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.screen\">System.Windows.Forms.Screen</a></p>\n",
            "tags": [
                "winform",
                "csharp",
                "窗口控制"
            ]
        },
        {
            "id": "https://blog.samhou.top/Csharp%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E7%84%A6%E7%82%B9(%E5%89%8D%E5%8F%B0%E7%AA%97%E5%8F%A3)/",
            "url": "https://blog.samhou.top/Csharp%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E7%84%A6%E7%82%B9(%E5%89%8D%E5%8F%B0%E7%AA%97%E5%8F%A3)/",
            "title": "Csharp强制设置系统焦点(前台窗口)",
            "date_published": "2023-01-27T01:01:20.000Z",
            "content_html": "<h2 id=\"系统焦点\"><a href=\"#系统焦点\" class=\"headerlink\" title=\"系统焦点\"></a>系统焦点</h2><p>在Windows中，系统的焦点就是当前处于前台的窗口。通过设置焦点，可以控制用户正在使用的应用程序。这里以winform应用为例。</p>\n<h2 id=\"Api调用\"><a href=\"#Api调用\" class=\"headerlink\" title=\"Api调用\"></a>Api调用</h2><p>C#需要调用Win32 Api才可以控制焦点，这里用到的是user32.dll中的SetForegroundWindow()函数</p>\n<p>在微软提供的文档中[1]，可以看到C++里的用法：</p>\n<pre class=\"highlight\"><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">SetForegroundWindow</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  [in] HWND hWnd<span class=\"comment\">//窗口句柄</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br></pre>\n\n<p>C#里没有HWND类型，与之对应的是IntPtr类型，所以可以这样导入Api[2]</p>\n<pre class=\"highlight\"><span class=\"line\"><span class=\"keyword\">using</span> System.Runtime.InteropServices;<span class=\"comment\">//这是调用所必须的</span></span><br><span class=\"line\">[<span class=\"meta\">DllImport(<span class=\"string\">&quot;user32.dll&quot;</span>)</span>]<span class=\"comment\">//调用dll</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"built_in\">bool</span> <span class=\"title\">SetForegroundWindow</span>(<span class=\"params\">IntPtr handle</span>)</span>;<span class=\"comment\">//这个函数签名必须和文档一模一样</span></span><br></pre>\n\n<p>下面来调用导入的内容（以设置edge浏览器为例子）</p>\n<pre class=\"highlight\"><span class=\"line\">Process[] processes = Process.GetProcessesByName(<span class=\"string\">&quot;msedge&quot;</span>);<span class=\"comment\">//查找edge浏览器进程</span></span><br><span class=\"line\">IntPtr handle = processes[<span class=\"number\">0</span>].MainWindowHandle;<span class=\"comment\">//获取主窗口句柄</span></span><br><span class=\"line\">SetForegroundWindow(handle);</span><br></pre>\n\n<p>但是，文档上指出这样设置需要满足几个条件中的任意一个：</p>\n<blockquote>\n<p>此过程是前台进程。&#x2F;进程由前台进程启动。&#x2F;进程收到了最后一个输入事件。&#x2F;没有前台进程。&#x2F;正在调试该过程。&#x2F;前台进程不是新式应用程序或“开始”屏幕。&#x2F;前台未锁定， (请参阅 <a href=\"https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-locksetforegroundwindow\">LockSetForegroundWindow</a>) 。&#x2F;前台锁定超时已过期， (在 <a href=\"https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa\">SystemParametersInfo</a>) 中看到<strong>SPI_GETFOREGROUNDLOCKTIMEOUT</strong>。&#x2F;没有活动菜单。&#x2F;当用户使用另一个窗口时，应用程序无法强制将窗口强制到前台。 相反，Windows 会闪烁窗口的任务栏按钮以通知用户。</p>\n</blockquote>\n<p>这样就不能说是强制设置了（注意，调试程序时系统允许强制设置，但只要离开调试器，就不行了），所以下面给出一个特别的方法。</p>\n<h2 id=\"强制设置\"><a href=\"#强制设置\" class=\"headerlink\" title=\"强制设置\"></a>强制设置</h2><p>Windows中，只要是新启动的窗口，总是能够获得系统的焦点。所以只要让程序重新启动，就能拿到焦点，变成前台进程，此时就可以设置焦点，达到强制的效果。</p>\n<p>这里还用到了另一个Api <code>GetForegroundWindow()</code>用于获取当前焦点[3]，调用方式同上，此处不再解释。</p>\n<pre class=\"highlight\"><span class=\"line\">[<span class=\"meta\">DllImport(<span class=\"string\">&quot;user32.dll&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> IntPtr <span class=\"title\">GetForegroundWindow</span>()</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">Process[] processes = Process.GetProcessesByName(<span class=\"string\">&quot;msedge&quot;</span>);</span><br><span class=\"line\">IntPtr handle = processes[<span class=\"number\">0</span>].MainWindowHandle;</span><br><span class=\"line\">SetForegroundWindow(handle);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (handle!=GetForegroundWindow())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     Process.Start(Application.ExecutablePath);</span><br><span class=\"line\">     Environment.Exit(<span class=\"number\">0</span>);<span class=\"comment\">//重启</span></span><br><span class=\"line\">&#125;</span><br></pre>\n\n<p>注意，该方法仅30%成功率，若连续10次重启仍未获得焦点，建议放弃(</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] <a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow\">https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow</a></p>\n<p>[2] <a href=\"https://www.cnblogs.com/code1992/p/5965997.html\">https://www.cnblogs.com/code1992/p/5965997.html</a></p>\n<p>[3] <a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getforegroundwindow\">https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getforegroundwindow</a></p>\n",
            "tags": [
                "csharp",
                "窗口控制",
                "焦点"
            ]
        }
    ]
}