[{"title":"委员长奇遇（4）","url":"/%E5%A7%94%E5%91%98%E9%95%BF%E5%A5%87%E9%81%87%EF%BC%884%EF%BC%89/","content":"16“Blue Archive已停止运行。”平板上突然出现了一个弹窗。\n“什么情况？我游戏崩了？”Player点了一下确定，系统把进程关闭了。\n“今天的情况太奇怪了吧？先是莫名其妙的剧情，又是崩溃的游戏……要不找找客服？算了，先刷会视频，然后等会把那段剧情看完再说吧。”\n“Blue Archive～Touch To Start”半小时后，Sensei登录了游戏。\n17“尸体……不，Sensei这是怎么了？”濑名来到了日奈的家里。\n“我也不知道啊……我只是问了几句话，他就这样了。”\n“这……完全不像得病或受伤的样子……感觉这像完全静止一样……”\n“不，这是未响应状态。”一个通讯突然接入了日奈的手机，传出了小玉的声音。\n“啊？原来你一直在监听吗？”日奈有些生气。\n“为了保证所有参会者对Sensei没有贸然的告密，这是必须的，而且通过了千年研讨会的批准。Sensei目前处在一种抛出了异常的状态，我们猜测是服务器的错误处理程序正在处理异常。”小玉说道。\n“未响应？参会者？告密？你们在说些什么？”濑名问到。\n“看来，是时候告诉你世界的真相了。”\n一份文件通过投影显示在了两人的面前，里面是关于千年对世界本质的研究，比会议上所说的更为详细。\n18Sensei来到日奈家的前一小时。\n“我们有了进一步的推测，现在就来机房找贝里塔斯。”柚子像真寻部长发了MomoTalk后，带着游戏部的几位来到了机房。\n“我想问一下，你们得出了这里是一个服务器，并且说我们是被外部真实世界的人所创造的，对不对？”柚子问到。\n“没错，这就是我们的计算。”\n“但是，为什么我们可以计算出来呢？如果外部世界创造了我们，那么也就是说我们的每一句话，每一个行动都是外部世界的人创造的。那么外面的人，怎么可能让我们知道自己身处虚拟世界之中？”\n“对呀，如果我们的世界是一个游戏，那么剧本根本不会这样写啊？除非是Meta类的……”桃井补充道。\n“不，那或许就是他们的目的。”阳葵突然从门外进来了。\n“为什么？”几人十分惊讶。\n“我也不知道，我们也不可能知道，更不可能证明。这只是一种猜想而已。”\n“等等，日奈那里出问题了。”小玉说道，把监听器的外放打开了，日奈和老师的对话清楚地传了出来……\n“先不要打断她，看看她说了什么。”\n19“老师的未响应状态，一定过一会就会解除。”小玉通过通讯说道。\n“格黑娜的委员长，能听见我说话吗？”阳葵的声音也从通讯里传了出来。\n“对不起……是我没有控制好情绪，也没有保守好秘密。”阳奈自责地说道。\n“没关系的。目前还没有造成什么影响，而且这种关于世界本质的消息，对于大家来说确实都难以接受。”阳葵指出，“而且通过这次的事件，我们又得出了结论——”\n“这个世界的老师的一言一行，只是创造我们这个世界的人规划好的。换句话说，Sensei不是现实世界中的Player真实人格的表达，而是创作者的产物……”\n20“啊……这是哪里？”在濑名看完文件离开后，老师突然动了起来。\n“老师，我们去海边玩吧！我觉得，是时候转换心情了。”日奈突然说道。\n“啊？”突如其来的一句话，让老师呆住了。\n“好啦，我们赶紧走吧……夏莱那里已经帮您请过假了。”\n“啊？这么突然？”\n“这不是刚刚老师自己说的吗？”\n“好像是有这么回事啊……那么，我们现在就出发吗？”\n“走吧！游泳圈和泳装都带好了！”\n","categories":["小说"],"tags":["网络游戏","小说","蔚蓝档案","科幻","手机游戏"]},{"title":"委员长奇遇（3）","url":"/%E5%A7%94%E5%91%98%E9%95%BF%E5%A5%87%E9%81%87%EF%BC%883%EF%BC%89/","content":"11“大家可能猜到了，那一次，Sensei介入了这个时间点。具体发生了什么我这里就不赘述了，如果各位感兴趣可以自己看资料。”\n“对啊……Sensei来自于外部世界，他观测到我们的变化之后就可以从外部对这个世界进行改变了。”\n“所以我们这次找各位过来，就是为了解决这个世界的问题。这个世界存在终止点，一定是因为外部世界产生了某些问题导致的。我们要做的，就是通过Sensei，设法让这个世界不要终止。”\n“不过大家千万不要贸然与Sensei谈论这些东西……我们无法预测这样做之后的后果。也就是说，我们只有一次机会，必须考虑好了再去说。否则，我们又需要借助时间跳转。更糟糕的情况是，我们还没有来得及跳转，这个世界就由于某些原因提前终止了。”\n“还有，要少对其他人说这件事！防止他们告诉Sensei。”\n12奇普托斯下起了小雨。\n日奈坐在车里，回忆着会上的内容。\n“这个世界，是虚假的吗……”她攥紧了手中的笔，自语道，“那么，我们的存在，又有什么意义？难道，我们只是Sensei用来娱乐的工具吗……我们并不以实体存在……”\n“难道，我和Sensei的感情，也只是现实世界中的人编造出来的吗……”泪水从她的脸上滑落。\n雨停了，但没有彩虹。\n日奈下了车，回到了自己的办公室。\n13“不对！这些理论有着非常大的漏洞！”游戏开发部内，柚子突然说道，“如果我们是外部‘现实世界’的人创造的，那么为什么我们会存在自我意识？我们为什么可以知道这是一个虚拟的世界？如果这真的是虚拟世界，是一个游戏，那么现实世界的人是不可能让我们知道的。她们是造物主一般的存在，绝对不会写出这样的故事。”\n“对啊，这绝对不可能！除非是有Meta元素的剧本，否则不可能这么写！”桃井赞同道。\n“不愧是UZQueen，对于游戏的理解很透彻。”绿称赞道，提出了自己的观点，“也许，贝里塔斯的计算，出了问题。”\n14“委员长她已经消失3天了，我们去敲门，她说自己想要静一静……”日奈家门前，亚子对收到Momotalk赶来的Sensei说。\n“日奈，是我，可以开下门吗？”\n“老师，请让我静一静……”日奈声音沙哑，似乎刚哭过。\n“我知道你可能遇到了什么事情，可以告诉老师吗？”\n“不行。”\n“那么……日奈酱，我们一起去海边玩好不好？看看风景，心情似乎也会变好呢。”\n“……”门打开了。\n“老师，请进来吧，我有一些问题要问……”\n15“老师，请问，作为学生的目的是什么？”\n“目的？当然是学习知识和技能啊？”\n“那么，我们为什么存在？换句话说，我们存在的目的究竟是什么？”\n老师愣住了。\n“日奈酱？你是不是发烧了？”老师伸出手，打算去摸日奈的额头。\n老师的口袋里，有什么东西亮了起来。\n日奈推开老师的手，说：“老师，回答我的问题吧……既然您不来自这个世界，那么您一定知道什么吧……”\n老师突然不动了，变成了一个完全静止的“物体”。\n日奈尝试拉起老师的手，却发现自己怎么也拉不动。\n“Sensei？您还好吗？”\n没有回应。\n“亚子！Sensei好像不太对劲……快去找医生！”日奈对门外的亚子喊道。\n","categories":["小说"],"tags":["网络游戏","小说","蔚蓝档案","科幻","手机游戏"]},{"title":"委员长奇遇（2）","url":"/%E5%A7%94%E5%91%98%E9%95%BF%E5%A5%87%E9%81%87%EF%BC%882%EF%BC%89/","content":"06“老师？我进来了哦。”日奈推开了夏莱办公室的大门。\n“日奈酱？今天没有很多需要处理的工作……”老师正拿着平板查看Momotalk，和学生聊着天。\n“老师！有紧急需要批改的文件！”步梦打开门把文件放在了桌子上。\n“好吧，现在有了……”老师颇为无奈，说道，“日奈酱要来帮忙吗？只需要帮我排序一下那些文件的优先级就好。”\n夏莱的办公室，是学生们和老师增进感情的地方。在这里，永远有做不完的工作，也有互相鼓励的老师与学生……\n“这个故事，很快就要被扭转了。”“巨匠”口中冒出了一句话。\n其实，他自己也不知道为什么这么说，却下意识的说出了口……\n07“好的，我们明天会准时到场的。”游戏开发部的几位答应了优香。\n“注意，千万不要让老师知道。否则，会产生影响世界的严重后果。”柚子把邀请信翻过来，一行小字映入眼帘。“这是什么意思？”开发部的几位困惑不已。“明天……只要再过大概20多个小时就能知道了。”桃井计算着时间。\n“爱丽丝会保守秘密的！”\n08“好……好多人啊……”柚子带着桃井，绿和爱丽丝走了进来，见到那么多人，她的脸色并不好。“千年会找我来做什么呢……”日奈自言自语着，找了个位置坐了下来。\n“各位都到齐了吧？”阳葵的轮椅驶入了计算机房。\n“接下来我所说的事情，可能令人难以相信，但请听我们说完，我们会拿出足以证明结论的证据。还有接下来的话，请对Sensei保密！”莉音会长也来到了这里。\n小玉按下了鼠标，一张服务器的图片显示在了投影上。\n“其实，这才是这个世界本质的样子。”\n09会场顿时安静了下来。\n“什么？”除了贝里塔斯，大家异口同声。\n“各位可能觉得难以置信，但事实就是这样。我们通过大量计算和实验，得出了令我们也觉得惊讶的结论。”阳葵补充道。\n“具体怎么证明？”日奈问道。\n“这就要从另外一个巨大突破说起了。在1个月前，我们开发出了时间跳跃器，可以将特定对象移动到任意时间点，移动后对象所处的位置由目标时间点决定。这就是说，时间旅行是可行的！您应该察觉到，前天您有了一次特别的经历……”\n“什么？原来是这样吗？怪不得那种感觉那么真实……”\n“我们通过计算，得出我们的时间跳跃存在限度。也就是说，这个世界的时间存在起始点和终止点。而最后的一个时间段中，日奈委员长与老师相见。老师说，他会永远记住委员长。”\n难道她们都看到了……日奈脸上泛起红晕。\n“这成为了证明这里是一个服务器的证据之一，而Sensei并不来自这个世界，在这个世界结束的时候很可能要回到自己的世界里去……”\n10“也就是说，我们可以知道整个世界从开始，到结束所发生的所有事情？”柚子首先理解了贝里塔斯的话。\n“不，有一个问题。”日奈开口了，“如果我们已经知道了一件事情会发生，那么如果我们特意不去在这个时间点做这件事呢？那么不就会发生变化吗？”\n“这正是我想补充的。预测未来是不可能的。当我们处于某个时间点时，我们可能会对于时间点后的历史进程作出任何影响，目前来说这是不可预测的。而当我们再次跳转回来时，由于已经提前观测到了要发生什么，所以‘知道要发生什么’这件事本身对于当前的时间点就是个变化，也就会对于历史进程做出影响，因此我们的观测也就失效了。“\n”换句话说，时间一旦向前跳转，后面的历史进程观测就会失效。所以我们才会只向后跳转，然后跳转回来，而不是向前，否则谁也不知道会不会改变‘发明时间跳转’这一个事件。”\n“那么时间限度也可以改变吗？”\n“我们尝试了很多次，都不行。这也是我们得出这是一台服务器的关键证据。这个世界是被人操控的，所以时间限度才不会变化。也就是说，我们内部世界的变动不会影响到外部世界，因为外部没有观测到我们的变化，也就自然不会改变了。”\n“但是，有一次，这个时间限度产生了变化。”莉央突然说了一句。\n“什么？”\n","categories":["小说"],"tags":["网络游戏","小说","蔚蓝档案","科幻"]},{"title":"委员长奇遇","url":"/%E5%A7%94%E5%91%98%E9%95%BF%E5%A5%87%E9%81%87/","content":"01清晨的格黑娜，天还是蒙蒙亮的，学生们还没有来到校园，但某一间房间却亮着灯。\n“还有一点文件没有处理完……还不能休息……”日奈喃喃自语，眼皮却快合上了。\n终于，她实在无法抵抗睡意，倒在桌子上睡着了。\n02日奈张开眼睛，却发现身处一个陌生的环境，而面前的人，是Sensei。\n“这里是？”正当她在纳闷自己到底是怎么睡着，又是如何在醒来时见到Sensei时，面前的人开口说话了。\n“日奈，你是我永远的好学生……”Sensei抱住白发少女，日奈顿时感受到了Sensei怀里的温暖。日奈先是疑惑，稍后却释然了——或许她还在做梦，但是就这样在老师的怀里也不错，就当这是个梦境吧。\n突然，温暖的感觉终止了，迎接她的是无边的黑暗。\n她所不知道的是，在某个世界某处的一个显示终端上，出现了一段文字：\nxxxx-xx-xx 00:00:01 Blue Archive Server: 正在停止服务器……\nxxxx-xx-xx 00:05:43 Blue Archive Server: 服务器已成功关闭。\nxxxx-xx-xx 00:06:21 System: 正在关机……\n03“这只是一堆数据和代码，她们并不存在。”\n“现实与虚拟之间，终究有不可逾越的鸿沟。“\n在见了自己的所有学生最后一面后，Sensei合上了自己的平板。这时，他不再被称为老师，而是Player。学园与青春的故事，最终还是落下了帷幕。\n“与你的相遇，便是奇迹。现在，果然连奇迹也发生不了吗……”\n04“命运已经确定，终点是无法改变的……”\n黑暗中，日奈听到了这样一句话。\n再次睁开眼睛时，她回到了熟悉的办公桌。“果然是梦吗……梦里Sensei的话到底是什么意思呢……还有那个神秘声音到底是谁……”她自言自语道。\n“好久没有像刚才那样靠在老师的怀里了啊……”日奈正准备继续处理文件，却突然瞥到了桌上的备忘录——“2-4日，夏莱值日”。一旁的闹钟上，“xxxx-2-4 8:12”让日奈瞬间清醒了。\n她赶紧洗漱了一下，抄起背包和手机就准备出门前往夏莱。\n这时，门外传来敲门声，“委员长，您在里面吗？”亚子的声音传了过来。“亚子？进来吧。”\n“您这是要去夏莱吗？我们收到了千年的联络，似乎提出了与您合作，具体内容她们想亲自和您说，时间是明天下午2点，贝里塔斯的计算机房。”亚子把手上的文件递给日奈，告别后便离开了。\n“千年吗……”日奈若有所思。\n窗外，太阳升了起来，早晨的格黑娜街道上，充满了学生们的欢声笑语。\n05“你们又通宵玩游戏了是吧？再不拿出新的成果，游戏开发部的经费会不会减少就不能确定了哦——”优香打开游戏部的大门，游戏部的几个学生正拿着手柄玩PrayStation。\n“不要啊——”桃井赶忙掏出了桌子上的剧本，“这是我前天写的……”“立绘已经画好了……”绿打开了电脑上的文件，“柚子前天也写了游戏的处理逻辑……”\n“爱丽丝也有在好好测试游戏！”爱丽丝从柜子旁边跳了过来。\n“好了，下次不要熬夜了……更不要通宵……”优香打开柜子，递给柚子一份正式文件，“这是贝里塔斯的邀请……具体要干什么我也不清楚，只是她们和阳葵还有莉央，共同通过研讨会向你们发出了邀请。”\n“此事触及世界的本质，希望你们可以到场……”柚子拆开信封，一行小字映入眼帘。\n-1（作者的话）作者是理科生，可以算是渣笔，这只是一个小小的尝试，我会持续创作《委员长奇遇》，尽量做到不OOC，具体会写多长我也不知道（毕竟是第一次写小说），喜欢的话可以在点个关注和赞。这个系列全部创作完毕后，我会将其转化为视频（达到Azure Archive剧情编辑器所能实现的剧情效果）。\n","categories":["小说"],"tags":["网络游戏","小说","蔚蓝档案","科幻"]},{"title":"《游戏：从下载到游玩》——手机国际服&Steam端游完全免魔法攻略","url":"/%E3%80%8A%E6%B8%B8%E6%88%8F%EF%BC%9A%E4%BB%8E%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%B8%B8%E7%8E%A9%E3%80%8B%E2%80%94%E2%80%94%E6%89%8B%E6%9C%BA%E5%9B%BD%E9%99%85%E6%9C%8D&Steam%E7%AB%AF%E6%B8%B8%E5%AE%8C%E5%85%A8%E5%85%8D%E9%AD%94%E6%B3%95%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%94%BB%E7%95%A5/","content":"前言由于很多人似乎对游玩Steam和手机国际服游戏存在障碍，因此笔者写了这篇文章，来帮助想要玩各种游戏的读者。此篇文章将包含以下内容：\n\nSteam的下载/游玩攻略/常见问题\n手机国际服如何下载/正常游玩\n如何挑选一款性价比高的、合规有效的加速器\n\n观前提示（必看）\n软件下载请认准官网，建议使用的搜索引擎是必应(cn.bing.com)，注意搜索引擎前几条可能是广告！\n本文没有任何广告，推荐的软件/服务均为笔者自己使用，仅做参考，可自行寻找替代品\n请关注评论区，若文章有误/更新会在评论中发布，也欢迎提问/质疑，但请先进行网络搜索/认真阅读后再提问\n以下使用缩写：STW(Search the web)表示搜索互联网自己找答案\n如果有问题，优先STW，再向他人求助\n\n选择一款合适的加速器\n加速器有什么用？顾名思义，它可以加速你与游戏服务器之间的网络连接速度\n什么情况下需要加速器？Steam必备，国际服手游大部分必备，具体STW\n在使用之前，先在b站内搜索评测视频（笔者没有评测过，链接也不放了，反正搜一下就有）\n想玩手机游戏的，请选择一款多端通用加速器\n大部分加速器对于Steam都是免费的，可白嫖，比如笔者目前用的雷神、UU（限时）等\n\nSteam如何下载Steam？\n先开加速器\n打开网址：https://store.steampowered.com/,点击安装Steam\n警告！切勿在搜索引擎上自行搜索后随便点击错误的网址，否则你下载的Steam可能不是正版！请认准上面的官网\n上方的这才是Steam的图标\n警告！存在问题的Steam可能导致盗号，尽量在自己的计算机上安装使用！安装前确认无病毒和间谍、流氓软件！\n接下来就是注册并使用了，傻瓜式的，不用多说，注意使用时全程需要加速器打开\n\n怎么买游戏\n打开Steam的商店，直接搜游戏名称或者随便逛逛，然后买就行了\n支付问题：支付宝付款时可能无法正常加载支付宝页面，此时可关闭加速器重试。（使用网页端购买，能够有刷新界面的选项，相比于客户端更优）\n警告！不要相信低价商家提供的破解入库程序！曾经有Up主揭秘，有些号称正版激活码的，看似让你填写激活码，实际可能向你提供破解程序，假装成”激活助手“，然后注入Steam客户端，使用家庭共享来达到入库效果，这样非常容易封号！只有三种正规获取游戏方式：直接购买，激活码激活，朋友赠送\n买游戏之前，先到steamdb上查一下历史价格，如果现在不打折可以等等，具体攻略STW\n\n买游戏避坑\n先看看评论，有些游戏可能单机模式也需要连接服务器，且需要加速器\n评论是能很好反映游戏质量的，记得仔细看看\n买之前先看看语言支持情况和硬件需求\n如果能阅读英文，建议在设置里设置第二语言为英文，这样评论会多一些，并且游戏推荐也会更多\n\n手机/平板端国际服安卓谷歌三件套在开始之前，你的手机/平板必须已经安装谷歌三件套，如果你不知道这是什么，请STW\n游戏安装包获取（国际服无需Google Play）请先STW，关键词“安卓手机端游戏应用商店”，下载一个合适的海外应用商店，目前笔者在用的是Qooapp，具体STW此处略去\n怎么安装/遇到问题怎么办\n警告！安装外部来源安装包时，建议关闭含有“安全守护”，“增强纯净模式”等字眼的常见增强拦截功能以减少操作步骤（前提是你对安装包有信心），手机厂商可能会对某些安装包拦截/报毒，此时请检查安装包来源是否可信，一般大的应用商店不太会包含后门/病毒，可以放心忽略\n无法登录怎么办？如果需要加速器，请打开对应加速功能，若还是不行，请查看加速器的答疑界面或联系客服，也可以STW\n\n苹果笔者个人不喜欢苹果，因此也没有苹果设备，笔者只知道苹果可以通过注册不同区域的Apple ID来下载游戏，此处攻略建议STW，常用关键词”&lt;游戏名&gt;+苹果国际服游玩教程“\n作者的话其实没有一篇教程/攻略是完美的，这一篇也不例外。重要的是搜索与解决问题的能力，因此笔者在这里多次提到要STW，鼓励大家借助互联网的海量知识，而不是不思考、不探究就去发问。希望大家在读完这篇文章后，都能顺利地玩上自己喜欢的游戏~\n","categories":["游戏攻略"],"tags":["网络游戏","Steam","手机游戏","电脑游戏","单机游戏"]},{"title":"自行搭建Bing AI镜像免魔法访问Bing","url":"/%E8%87%AA%E8%A1%8C%E6%90%AD%E5%BB%BABing%20AI%E9%95%9C%E5%83%8F%E5%85%8D%E9%AD%94%E6%B3%95%E8%AE%BF%E9%97%AEBing/","content":"偶然发现了一个神奇的开源项目go-proxy-bingai，可以搭建直接可用的Bing AI镜像。\n准备工作\nGithub账号+邮箱一个\n一个自己的域名（可选）\n\n镜像首先打开上面的开源项目的地址（GitHub打不开自行搜索镜像），项目作者已经搭建好了几个网站，如果不会搭建可以直接用。\n开始自行搭建网页端作者提供了3种方式，Railway/Vercel/Render，各有优劣。\nRailway有每月运行时间限制200小时，到了就停机，且速度较慢。\nVercel无法使用其自带域名在国内直接访问，需要绑定自己的域名，但速度较快。\nRender也无法访问，速度慢。综合建议用Vercel，没域名的就用Railway吧。\n这部分的部署攻略作者已经做了图片提示，就不写教程了，各位自己看就行了。\n搭建聊天服务器目前作者提供了Cloudflare Workers方式进行部署，但CF worker国内也无法直接访问，所以还是需要自己的域名。\n首先，绑定域名到Cloudflare，你只需要在买域名的地方把dns改成Cloudflare提供的就行了。\n然后选择Workers 和 Pages，创建应用程序，把下面链接里代码复制贴进去Worker.js\n保存部署，然后再自定义域名那里添加域名，直接写一个子域名就行了，注意别和前面网页端重复（比如wbing.xxxx.xxx），然后网页端服务选择里自定义填上就行\n如果你想让你的网页端直接用上聊天服务器，那么你需要添加workers路由。\n先选择网站-你的域名，选择Workers路由，按照下面这样填写：\n\n然后再进网站，你会发现服务选择里的主站亮了，能用了。\n如果搭建失败，直接用项目原作者内置也不是不可以（\n","categories":["AI"],"tags":["AI","Bing"]},{"title":"AI绘画WebUI使用详解","url":"/AI%E7%BB%98%E7%94%BBWebUI%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/","content":"前言AI绘画目前主要使用的是在Github上的Stable-Diffusion-WebUI这个项目，链接：WebUI\n在整个安装、部署和学习的过程中踩了不少坑，所以写这么一篇文章来记录一下。\n要想对该项目进行实践，必须满足以下必要条件：\n\n电脑显存至少2GB，内存至少16GB\n可以访问Github\n\n安装与部署这里已经有了一篇完整的指南，这里不再赘述：Guide\n要注意的是AI绘画可以用很多不同的模型，热门的NovelAI在这篇指南的第二节\n这里有两点提醒：\n\n启动的是webui-user.bat，不要点错了\n如果你需要编辑webui-user.bat里的COMMANDLINE_ARGS，等号后面加的东西不需要任何引号！\n除非想要关闭面板，否则不要关闭打开的命令行黑窗口\n\n运行AI绘画根据上面的指南内容，应该已经打开了一个WebUI窗口（在浏览器里），现在你已经可以使用这个面板了，下面对部分内容进行翻译：\n\ntxt2img，字符转图片\nimg2img，图片转图片（将鼠标悬停在每一项上面，有详细的描述）\n\n由于这个教程是零基础的，所以这里只讲解txt2img这种简单方式，img2img不作提及。\n左上角的CheckPoint，就是当前选择的模型。在Prompt中，你可以用自然语言描述图片内容，Negative Prompt就是负面内容（画面中不应该出现），Sampling steps是采样步骤（可以理解为AI尝试修改的次数），Batch count一次生成的照片数量，Batch size同时生成的照片数量（就是几张图一起生成，加快速度，不过对性能要求也更高），CFG Scale是AI对你的内容的“遵守度”，数值越小，AI的自由发挥空间越大。\n关于调参、绘画等内容，由于本教程针对的是技术问题，此处略过，仅放链接：入门魔法书，Prompt词典\n加载模型你可能已经在上面的Guide中看到了一个网站，civitai，这是一个模型分享网站，可以下载到训练好的自定义的模型。\n这里有一个大坑：CheckPoint和其他类型是不一样的！！！模型会标注其类型，要放到WebUI的对应文件夹里！不是CheckPoint的模型放到Checkpoint里会产生奇怪的错误！我的理解是CheckPoint模型是基础，在基础上叠加其他类型来达到自定义的效果。模型怎么使用，一定要看看文档（在civitai模型类型旁边有个小问号，点进去就可以看到了）\n错误排除如果你遇到错误，先照着错误消息做，如果还是不行，最简单的方式就是问搜索引擎，把错误消息贴进去。也可以去Github Issues搜索，或者去读一读文档。\n结语本文讲了AI绘画的运行、部署之间的大坑，希望能够节约更多人的时间，避开坑，快速生成理想的作品\n","categories":["AI"],"tags":["AI"]},{"title":"对拖延的探索","url":"/%E5%AF%B9%E6%8B%96%E5%BB%B6%E7%9A%84%E6%8E%A2%E7%B4%A2/","content":"首先说一下，如果你在看这篇文章时正在拖延，请立即关闭并去做正事。\n拖延症应该是非常普遍的现象了，作为高中生，拖延症一直是个头疼的问题，下面是我个人的经验，更是对拖延症的解决的探索过程，如果有错误或更好的方法请指出。先来说说拖延的表现，绝对真实（因为这是真实经历😂）。\n拖延的症状\n做正事时玩手机\n视频网课暂停着去用浏览器看网页，或者打开其他软件瞎折腾\n作业做到一半打开电脑乱捣鼓设置\n刚看2分钟书就打开b站刷一下\n学习90分钟后决定休息30分钟打游戏，结果直接玩了1小时\n\n不是拖延的症状\n直播课摸鱼（这是注意力不集中）\n自己的兴趣爱好占用了非常多的时间，导致时间不够用（这是没有合理安排时间）\n\n探索阶段1：5分钟工作法一直看到各种学习方法论讲这个方法，具体就是一件事情如果你拖延不想干，就给自己定目标——做它5分钟，然后就会发现人会自然而然地继续做下去。实测，这方法对我一点用都没有。当你拖延时，根本想不到要去做5分钟，大脑只想再拖延一会。如果有人知道这方法到底怎么用，欢迎留言交流😂\n探索阶段2：整段时间法曾经有篇文章提到一个方法，就是把一整段时间拿出来去做一件事，比如要写作业，那就拿出一个下午（不知道够不够😂），只写作业，不干其他事情，在其它时间再干别的。实测，该方法有一定效果，但如果注意力无法长时间集中，这方法一点用没有。而且你还需要有拿出一整段时间的决心。\n探索阶段3：90-30工作法这方法很简单，做事90分钟，休息30分钟。实测，这方法有2个问题，第一，没有决心开始90分钟做事，或90分钟开始几分钟后就开始拖延；第二，休息拖延超时。\n至此，上述精神疗法宣告失败，是时候来点强制措施了！\n工具方法1：专注手机App专注的App一搜一大堆（安卓相比苹果体验更好，毕竟有悬浮窗可以造白名单，还可以搞各种高级权限），目前我用过以下几款\n\n不做手机控\nCostudy\nForest\n\n第一个，极为严格，直接锁手机（甚至能变砖），手机成瘾必备，不过太严格可能会在紧急时刻锁手机，设置需谨慎；第二个，线上自习室，主打陪伴，会沉迷交网友的谨慎使用；第三个，种树，限制不是很严，而且需付费，不喜欢种树的不推荐。\n目前我是第一和第二个一起用，效果还行，不过前提是需要有摆脱拖延的勇气才行，否则什么软件都救不了。\n我绝对不会告诉你安卓端可以用adb干掉一切专注软件\n工具方法2：电脑端专注软件好了，现在不玩手机了，改玩电脑了😂\n这块软件很少，毕竟电脑难控制，可能开发者们懒得做，或者估计没啥需求。\n找了不知道多久，终于是给找到了一款，叫番茄盒子，现在改名叫进客盒子，不过这软件得付费，而且价格不便宜，设置较为复杂，买了一年就不用了。\n既然没有理想中的软件，那我自己来整一个。于是用自学的C#做了这么一个东西，代码全开源在github（代码很烂，但会持续更新）：TimeControl时控\n其实任何软件都可以进PE/安全模式删掉，这点几乎无解，所以我写这程序也开摆了，只要重启，虚拟桌面屏保就没了，不过你可以用深度专注，电脑进了系统自动关机，虽然还是防不了PE/安全模式\n结论整了那么多，我只能说，所有方法只能缓解拖延，不可能根治拖延。之前看过一个TED Talk[1]，把拖延比作一只控制你大脑的猴子，而DDL就是能够吓走猴子的怪兽。所以说，有时候拖延症就是离DDL太远要合理安排时间，合理运用各种方法（包括上面的方法，不试一试怎么知道适不适合自己）来缓解拖延，最终目的就是完成任务学到自己需要的知识，提高考试分数。\n参考资料各种方法论到处都是，看到太多遍，此处不一一列举\n[1] https://www.bilibili.com/video/BV1MB4y1j78Z\n","categories":["学习方法"],"tags":["拖延症","学习方法"]},{"title":"Csharp强制设置系统焦点(前台窗口)","url":"/Csharp%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E7%84%A6%E7%82%B9(%E5%89%8D%E5%8F%B0%E7%AA%97%E5%8F%A3)/","content":"系统焦点在Windows中，系统的焦点就是当前处于前台的窗口。通过设置焦点，可以控制用户正在使用的应用程序。这里以winform应用为例。\nApi调用C#需要调用Win32 Api才可以控制焦点，这里用到的是user32.dll中的SetForegroundWindow()函数\n在微软提供的文档中[1]，可以看到C++里的用法：\nBOOL SetForegroundWindow(  [in] HWND hWnd//窗口句柄);\n\nC#里没有HWND类型，与之对应的是IntPtr类型，所以可以这样导入Api[2]\nusing System.Runtime.InteropServices;//这是调用所必须的[DllImport(&quot;user32.dll&quot;)]//调用dllpublic static extern bool SetForegroundWindow(IntPtr handle);//这个函数签名必须和文档一模一样\n\n下面来调用导入的内容（以设置edge浏览器为例子）\nProcess[] processes = Process.GetProcessesByName(&quot;msedge&quot;);//查找edge浏览器进程IntPtr handle = processes[0].MainWindowHandle;//获取主窗口句柄SetForegroundWindow(handle);\n\n但是，文档上指出这样设置需要满足几个条件中的任意一个：\n\n此过程是前台进程。/进程由前台进程启动。/进程收到了最后一个输入事件。/没有前台进程。/正在调试该过程。/前台进程不是新式应用程序或“开始”屏幕。/前台未锁定， (请参阅 LockSetForegroundWindow) 。/前台锁定超时已过期， (在 SystemParametersInfo) 中看到SPI_GETFOREGROUNDLOCKTIMEOUT。/没有活动菜单。/当用户使用另一个窗口时，应用程序无法强制将窗口强制到前台。 相反，Windows 会闪烁窗口的任务栏按钮以通知用户。\n\n这样就不能说是强制设置了（注意，调试程序时系统允许强制设置，但只要离开调试器，就不行了），所以下面给出一个特别的方法。\n强制设置Windows中，只要是新启动的窗口，总是能够获得系统的焦点。所以只要让程序重新启动，就能拿到焦点，变成前台进程，此时就可以设置焦点，达到强制的效果。\n这里还用到了另一个Api GetForegroundWindow()用于获取当前焦点[3]，调用方式同上，此处不再解释。\n[DllImport(&quot;user32.dll&quot;)]public static extern IntPtr GetForegroundWindow();...Process[] processes = Process.GetProcessesByName(&quot;msedge&quot;);IntPtr handle = processes[0].MainWindowHandle;SetForegroundWindow(handle);if (handle!=GetForegroundWindow())&#123;     Process.Start(Application.ExecutablePath);     Environment.Exit(0);//重启&#125;\n\n注意，该方法仅30%成功率，若连续10次重启仍未获得焦点，建议放弃(\n参考文献[1] https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow\n[2] https://www.cnblogs.com/code1992/p/5965997.html\n[3] https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getforegroundwindow\n","categories":["Csharp"],"tags":["csharp","窗口控制","焦点"]},{"title":"Csharp接口进阶","url":"/Csharp%E6%8E%A5%E5%8F%A3%E8%BF%9B%E9%98%B6/","content":"在这篇文章里，曾经讲解过C#接口的基本概念。掌握这些基本概念后，本文将补充一个进阶内容。\n显式接口成员实现\n该功能用于为同一个类中实现的不同接口创建不同的方法（方法名称相同）\n语法：\n\ninterface I1&#123;void Method(string s);&#125;interface I2&#123;void Method(string s);&#125;class MyClass:I1,I2...void I1.Method(string s)&#123;...&#125;void I2.Method(string s)&#123;...&#125;\n\n\n当以上面的方式来创建类中的方法时，仅能通过接口引用访问该方法，无法通过类的引用来访问，即使是同一个类中的方法也不行\n针对以上问题，可以通过强制转换来进行，举个例子：((I1)MyClass1).Method\n\n","categories":["Csharp读书笔记"],"tags":["csharp","csharp图解教程"]},{"title":"Csharp-winform窗口拖动详解","url":"/Csharp-winform%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E8%AF%A6%E8%A7%A3/","content":"代码实现\n首先，在设计器里双击增加以下三个方法，然后填入以下代码      private Point mouseLocation;//表示鼠标对于窗口左上角的坐标的负数private bool isDragging;//标识鼠标是否按下      private void MainWindow_MouseDown(object sender, MouseEventArgs e)      &#123;          if (e.Button == MouseButtons.Left)          &#123;              mouseLocation = new Point(-e.X, -e.Y);              //表示鼠标当前位置相对于窗口左上角的坐标，              //并取负数,这里的e是参数，              //可以获取鼠标位置              isDragging = true;//标识鼠标已经按下          &#125;      &#125;      private void MainWindow_MouseMove(object sender, MouseEventArgs e)      &#123;          if (isDragging)          &#123;              Point newMouseLocation = MousePosition;              //获取鼠标当前位置              newMouseLocation.Offset(mouseLocation.X, mouseLocation.Y);              //用鼠标当前位置加上鼠标相较于窗体左上角的              //坐标的负数，也就获取到了新的窗体左上角位置              Location = newMouseLocation;//设置新的窗体左上角位置          &#125;      &#125;      private void MainWindow_MouseUp(object sender, MouseEventArgs e)      &#123;          if (isDragging)          &#123;              isDragging = false;//鼠标已抬起，标识为false          &#125;      &#125;\n详解\n鼠标在窗体上按下时，窗体跟随鼠标，鼠标抬起时，窗体停止移动\n窗体的Location属性为左上角的坐标\n为了实现拖动，需要获取2个坐标：鼠标相较于窗体左上角的位置，以及鼠标现在的坐标\n举个例子：按下鼠标时，鼠标位置(300,400)，获取鼠标相较于窗体左上角位置为(150,100)，那么此时窗体位置是(150,300)，鼠标移动到(300,401)，那么此时窗体位置应该是(150,301)。也就是说，新的窗体位置就是新的鼠标位置减去一开始鼠标相较于窗体左上角位置\n调用.OffSet()，就是把前面的坐标加上括号里的坐标，比如上面的例子，newMouseLocation是(300,401)，mouseLocation把鼠标相较于窗体左上角位置作为负数存储，mouseLocation是(-150,-100)，那么新的newMouseLocation就是(150,301)了~\n\n","categories":["Csharp"],"tags":["winform"]},{"title":"Csharp读书笔记（六）-枚举与集合","url":"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E9%9B%86%E5%90%88/","content":"枚举\n枚举只允许几个特定的值\nenum数据类型只允许某个数据取某些特定的值enum Computers&#123;\tComputer1=1,//不仅可以指定名称，还可以指定值\tComputer2=2,\tComputer3=3,//这个逗号可以省略&#125;\nenum也是一种类型，每一项都可以当作参数传递，如Computers.Computer1这样传递\n枚举中的每一项都必须有名称，但不一定需要指定一个值\n可以使用.ToString()方法来获得任意一项的名称，使用强制转换获得其值\n比如：Computers.Computer1.ToString()得到stringComputer1,(int)Computers.Computer1得到int1\n也可以把int转换回去，例如Computers computer0=(Computers)3;该代码会创建一个指向Computer3的引用computer0（因为等号右边的数字是3，回到Computers中寻找值3，所对应的项为Computer3)，于是computer0.ToString()获得的就是stringComputer3了\n如果没有为项指定值，那么C#会自动按照顺序赋值，第一项为0，以此类推\n可以用:指定所需要的类型，例如enum Computers:long这样就可以为其中的项指定非常大的值了\n\n集合列表与数组\n每个数组都有一个长度，它是固定的，需要手动调整长度\n不能直接移动数组的元素\n可以使用集合来存储数据，就可以避免以上两个问题\n常用的集合是List&lt;T&gt;，&lt;T&gt;表示类型，把类型放在尖括号中间\n使用.Add()可以添加集合中的项目\nList没有大小限制，它会动态调整大小\nList有多态性，也就是可以添加接口、抽象类、基类等\n\nList的使用\n.Contains()可以检查是否有特定元素，括号内写上需要查找的元素\n.IndexOf()可以获取特定元素的索引，括号内写上需要查找的元素\n.Remove()可以删除元素，括号内写上需要删除的元素\n.RemoveAt()可以删除元素，括号内写上需要删除元素的索引号\nList本身也是一个对象\n\nforeach循环\nforeach可以对list中每个对象执行语句，数组也可以这么用\n注意，使用foreach时不能修改这个集合，也就是不能使用该list对应的.Remove()等方法\n.ToList()可以创建副本并赋值给新的变量\n使用foreach就是在使用IEnumerable&lt;T&gt;\n以下代码实现的效果完全相同foreach (Duck duck in ducks)\tConsole.WriteLine(duck);//上下两种方式实现的效果完全相同IEnumerator&lt;Duck&gt; enumerator = ducks.GetEnumerator();while (enumerator.MoveNext())\tConsole.WriteLine(enumerator.Current);IDisposable disposable = enumerator as IDisposable;if (disposable != null) disposable.Dispose();\n\n集合初始化方法\n可以用集合初始化方法来提供初始数据项列表\n直接在创建列表后面添加大括号，各个初始项中使用逗号隔开\n可以包含new创建的对象，还可以包含变量\n\n集合的排序\n.Sort()可以使列表中的所有项重新有序排列，它已经知道如何重排大部分类型\n有两种排序方法，分别是CompareTo()和实现IComparer&lt;T&gt;\n\n排序1：使用CompareTo()方法\n.Sort()知道如何对实现了IComparable&lt;T&gt;接口的类排序\n该接口只有一个成员，是CompareTo()方法，传入一个要比较的对象\nCompareTo()方法会返回一个int值，该方法传入一个要比较的对象x，它把传入的对象与当前对象y（也就是该方法所在的对象）比较，如果x应排在y后面（也就是x&gt;y）则返回正数，反之则返回负数。如果比较相同，则返回0。（如果你实现了正向排列，想要倒序排列，只需在调换正负数的位置即可）\n实现接口后，直接使用.Sort()即可排序\n\n排序2：新建一个实现了IComparable&lt;T&gt;的类\n可以向.Sort()传入一个实现了IComparer&lt;T&gt;接口的实例\n该接口有一个Compare()方法，传入两个要比较的对象\nCompare()方法会返回一个int值，该方法传入两个要比较的对象（假设它们是x,y），它把传入的两个对象比较，如果x应排在y后面（x&gt;y），则返回正数，反之则返回负数。如果比较相同，则返回0。（如果你实现了正向排列，想要倒序排列，只需在调换正负数的位置即可）\n实现接口后，先实例化这个新比较类，然后调用list对象的.Sort()，把新的实例填到括号内，即可比较\n\n多种排序方式\n可以用第二种方式写不同的比较类，只要填入不同排序类，就可以以不同的方式排序\n注意，以上两种方法可以共存。共存时，.Sort()括号内可以不写，也可以填入比较类，此时会执行比较类中的方法（不会执行CompareTo）\n也就是说，第二种方式有更大的灵活性！\n\nToString()方法\n每一个对象都有一个ToString()方法，把对象转换为一个字符串\n使用+操作符会自动调用该方法，调试工具中的监视也用到了这个方法\n它默认返回类名，但是我们可以覆盖它，让它返回不同的内容\n\n列表的向上强制转换\n列表的向上强制转换称作协变\n实现了IEnumerable&lt;T&gt;接口的类才可以向上强制转换\n使用该接口引用即可转换IEnumerable&lt;BaseClass&gt; upcastBaseClasses = subclasses，这里subclasses即子类的列表，这个子类实现了IEnumerable\n强制转换后，可以用AddRange把内容添加到另一个列表中\n\n重载\n重载即有多个参数不同的同名方法\n直接写两个同名方法，即可使用重载\n\nIEnumerable\n这个接口表示实现了任何集合，不止是List或数组\n用于强制转换、foreach循环等\n\n字典\n字典可以将两个东西关联起来，形成一组\n前一个叫键，后一个叫值\n任何类型都可以！\n.Add(key,value)可以添加一个项目\n.ContainKey(key)可以返回是否有这个键\ndict[key]可以获得键对应的值\n.Remove(key)可以移除一项\nforeach(string key in myDict.Keys)可以遍历键\n.Count()可以获得项目数量\n\n更多集合类型——按顺序处理\n常用的按照顺序处理的集合是queue和stack\nqueue类型表示先处理早提交的对象\nstack则相反，先处理最后提交的对象\n\nqueue\n.Enqueue()向queue中添加一项\n.Peek()允许查看第一项\n.Dequeue()允许取出第一项，将后面的对象上移到空出来的位置\n.Count,.Clear()与list类似\n\nstack\n可以推入、弹出对象\n添加时用.Push()\n取出时用.Pop()\n.Peek()类似queue\n\n互相转换\nlist,queue,stack可以相互转换\n比如下面这样做Queue&lt;string&gt; myQueue=new Queue&lt;string&gt;(mystack);\n\n","categories":["Csharp读书笔记"],"tags":["csharp","hfc"]},{"title":"Csharp读书笔记（五）-接口与抽象类","url":"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/","content":"接口基本概念\n接口告诉类必须实现某些方法和属性\n如果没有实现，编译器会报错\n接口可以定义一个类中必须有的方法，这样一个类只要实现接口，就可以做特定的事情\n使用interface关键字定义接口\n接口不能添加任何字段，因为它不存储数据（但是可以包含属性）\n命名规范：接口名称以I开头\n只需要在接口中添加方法名和参数，因为接口不做任何事情\n接口中的所有方法都是抽象方法，不能有方法体 ^bbfa07\n一个类只能继承一个类，但可以实现多个接口 ^018e94\n不可以实例化接口，不过可以引用接口\n接口就像清单，指出一个类可以做些什么事情\n\n为什么使用接口？\n接口并不是为了避免重复代码，继承才是\n如果有一件事，多个类都能实现，你需要这样一个类作为参数，但不希望继承时（比如你觉得根本用不到那些东西，不想让子类继承基类的方法和属性），这时你无法用继承中的基类来作为参数，那么使用接口，就可以知道：只要类实现了这个接口，它就能做这件事，可以作为参数使用，而不必知道它到底是什么类型\n如果有多件事，一个类能实现它们，这时无法使用继承（只能继承一个类），就需要使用接口\n继承只是给类“分层”（减少重复），接口则可以给类“分类”（可以规定这个类可以干什么）\n也就是说，当继承给你的类增加太多“负担”时，就应该考虑使用接口\n举个例子，假设你有一个电器类，很多类都继承了它，比如电脑、电视、冰箱……但是现在你想要用一个可以处理食物的类作为参数（比如面包机、烤箱、微波炉……），这时无法使用继承（因为你只能继承一个类），就需要编写一个可处理食物的接口，把要用到的方法属性放进去，在可处理食物的类中实现这个接口，把参数改成这样一个接口引用，就可以解决这个问题\nC#拒绝继承多个类，并通过接口提供保护，这是为了避免二义性\n二义性：当两个类分别继承一个基类，并且重写了基类中的同一个方法，这时如果允许继承多个类（这称为多重继承），那么继承这两个类的子类调用该方法（假设子类没有重写）时应该调用哪个方法？这就会出现问题：子类不知道应该调用哪个方法，因为继承了两个同名的不同方法\n这也被称作“致命的死亡菱形”（如果[[Csharp/Csharp读书笔记/Csharp读书笔记（一）-对象与引用#创建类图|画出类图]]，会发现这像一个菱形）\n所以C#通过接口提供保护，接口并没有方法体（它不做任何事情），因为它没有方法体，所以一个类可以实现多个接口，即使接口中有同名方法，这个类也只能实现这一个方法，避免了二义性\n\n接口引用\n接口引用与对象引用类似，可以保持一个类不被垃圾回收\n可以移动接口引用，就像移动标签一样\n一个类需要实现这个接口，才能添加该接口引用\n使用接口引用访问类时，只能访问该接口引用所对应的方法和属性 ^46c854\n\n类与接口的强制转换\n可以使用is关键字来查看一个类是否实现了这个接口\n可以用as关键字来把一个类看成实现了这个接口（前提是使用is找出这个类确实实现了）\n为什么使用as：有时候，C#并不知道一个类实现了一个接口（使用了其他接口引用），所以使用is之后还要让C#认为它确实实现了\n举例： ^537c57\n\n//这里仅给出核心代码IComputer[] computers=new IComputer[3];//假设有一个叫做IComputer的接口computers[0]=new Windows();//假设Windows,Mac,Linux类实现了IComputer接口computers[1]=new Mac();computers[2]=new Linux();...for(int i=0;i&lt;computers.Length;i++)&#123; if(computers[i] is IServer)&#123; IServer myserver;//IServer是一个假设的新接口 myserver=computers[i] as IServer; //使用as，就能够让C#把这个对象看成实现了IServer,就可以使用IServer中的方法和属性了 myserver.Run();//假设IServer中有一个Run()方法，只有使用了as才能够使用 &#125;&#125;\n\n\n在上面的例子中，C#知道computers数组中的类都实现了IComputer（因为这是个IComputer接口的数组），所以只能调用这些类中IComputer接口中包含的方法和属性（可以把接口看作一个清单，这里只能调用清单中的内容），而当使用is关键字找出这个类确实实现了IServer接口时，C#仍然不认为它实现了IServer（因为你根本没有告诉它这么认为，只是让他检查了这个“清单”是否与类匹配，这是is关键字所做的），所以你需要使用as关键字，这样C#就会认为它确实实现了IServer，就可以（且只能）调用IServer中的方法、属性了\n由子类代替基类时，这称为向上强制转换\n由基类代替子类时，这叫做向下强制转换\n接口也可以这么做（上面的举例就是一个接口向下强制转换的例子）\n\n接口的继承\n接口可以继承其他接口\n实现继承其他接口的接口时，必须实现所有继承的接口\n\n访问修饰符\npublic表示任何其他类都可以访问\nprivate表示只有该类中的成员及该类的其他实例可以访问\nprotected表示对于该类的其他成员来说相当于private，而对于子类来说是public，也就是说子类成员可以访问子类成员及任何基类成员（注意：基类声明为protected后，无需使用base也可以访问基类中的公共类型）\ninternal表示只能从程序集或子类访问\nsealed表示不能继承该类\n\n抽象类\n抽象类不能实例化\n有时候，你想在一个类中完成一部分代码，在子类中再完成其余部分，于是基类根本不应该被实例化（它并不能工作——因为你没有完成它），这时应该使用抽象类，防止你不小心创建了本不应该创建的实例\n比如说，一个方法需要一个字段来计算，但是在基类中不想设置它的值，想在子类中设置，这时基类是不完整的，它无法计算，所以设置为抽象类，防止误实例化\n可以在抽象类中添加抽象方法，也可以有具体方法，这与接口不同\n\n面向对象的设计原则\n继承：一个类或一个接口继承另一个\n抽象：建立一个类模型，首先时比较一般的类，然后继承的是更特殊的类，也就是由一般（基类）到特殊（子类）的过程\n封装：创建一个对象，使用私有字段在内部记录其状态，通过公共属性、方法使其他类只能使用需要的数据以防止错误\n多态：将一个对象用于需要其他对象的方法或语句，比如类与接口的强制转换\n\n","categories":["Csharp读书笔记"],"tags":["csharp","hfc"]},{"title":"Csharp读书笔记（四）-继承","url":"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E7%BB%A7%E6%89%BF/","content":"继承基本概念\n继承可以构建彼此关联且有共同行为的类\n被继承的叫做基类\n继承别人的叫做子类\n类图中，箭头由子类指向基类\n沿着类图上行，可以发现类的相同特征越少\n沿着类图下行，可以发现类的相同特征越多\n这就好像生物的分类——界门科目纲属种\n使用冒号可以继承一个基类\n一个类只允许继承一个类，这是一种保护\n\n合并两个类\n首先创建类图\n找出两个类相同的字段与方法\n把相同的放到一个基类中去\n把不同的放在子类，要[[#覆盖]]的也需要写入\n画上子类指向基类的箭头\n\n覆盖\n在子类中，可以覆盖基类的方法\n举例，狗和猫都是动物，但是叫声不同，创建这样的类时，可以把Animal作为基类，Dog/Cat作为子类，在子类中覆盖Animal类的发出叫声的方法\n执行顺序：对于C#，执行方法时总是先从基类中寻找，如果在该子类中找不到，会沿着类图上行，一个个寻找，直到找到对应的方法 ^7e9264\n被覆盖的方法添加virtual关键字\n要覆盖别人的方法添加override关键字\n\n隐藏的方法\n如果不添加这些关键字，则不会覆盖方法，而是隐藏了基类中的方法\n隐藏会导致产生两个同名的方法 ^b0994f\n在隐藏方法时，需要为子类中的方法添加new关键字\n如果隐藏了方法，调用时会根据引用来执行，也就是调用对应引用类型的方法\n如果调用了一个子类引用中该子类对应基类中的方法，且该方法中调用了另一个隐藏的方法（有两个同名方法），则会执行对应基类中的隐藏方法\n\n继承的用法\n对于传递一个类的参数，如果该参数需要一个基类，则不仅可以传递该基类，还可以传递它的子类（任何一个都可以）\n传递后，只能使用对应传递的类中的内容\n比如传递一个基类，就不能使用它的子类的内容\n传递一个子类，也不能使用对应基类的其他子类中的内容\n子类可以使用base关键字访问基类中的方法，即使它们被覆盖了\n\n继承中的构造函数\n如果基类中有带参数的构造函数，则在子类中也必须调用其中一个\n但是，子类的构造函数与基类的构造函数可以有不同参数\n构造函数执行时，会从基类开始，沿着类图下行依次执行（这和覆盖的执行顺序正好相反）\n举例\n\nclass MyBase&#123;public MyBase(int number1)&#123; Console.WriteLine(number1);&#125;&#125;class MySub&#123; public MySub(int number1,int number2):base(number1)&#123; Console.WriteLine(number2); &#125;//output: number1 number2&#125;\n\n知识拓展\n让类尽可能减少重叠，这是一个重要的设计原则，称作关注点分离\nString.IsNullOrEmpty()可以检测一个字符串是否为空（即&quot;&quot;）或null\n\n","categories":["Csharp读书笔记"],"tags":["csharp","hfc"]},{"title":"Csharp读书笔记（三）-封装","url":"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E5%B0%81%E8%A3%85/","content":"封装\n封装保证类中一些数据是私有的\n私有字段、方法只能在类内部访问，使用关键字private\n封装可以避免不必要的错误\n\n属性\n属性对于其他对象来说就是字段\n可以通过属性获取或设置一个后备字段\n属性首字母大写，后备字段应小写\n属性的好处：在获取或设置时可以执行一些语句（比如设置一些有关的字段），防止直接更改字段导致逻辑计算错误\n获取get\n设置set\n每个set都有一个名为value的参数，获取的是设置的值\n可以只设置get或set中的一个\n举例：\n\nprivate int numberOfComputers;//这是一个后备字段private int displays;//这是另一个字段public int NumberOfComputers//这是一个属性&#123; get &#123;  return numberOfComputers; &#125; set &#123;  numberOfComputers = value;//设置后备字段  displays = value*2;  /*举例，每台电脑需要2个显示器，  *这样封装可以防止直接从外部  *修改displays，  *而外部代码可能发生错误导致dispalys不是2倍  *这就避免了不必要的错误  */ &#125;&#125;\n\n\n在窗体应用执行Console.WriteLine()时，输出显示在output窗口\n输入prop，再按下tab，会向代码中添加一个自动属性\n\n构造函数\n构造函数会在类创建时执行\n构造函数没有返回值\n添加构造函数时，需要添加一个与类同名的方法，但是没有返回值\n构造函数可以用来在创建实例时为私有变量指定值\n当然也可以做更多事情\n\n知识拓展\n方法的第一行包含存取修饰符、返回值、名字和参数，这些称之为签名\n属性也有签名\n\n","categories":["Csharp读书笔记"],"tags":["csharp","hfc"]},{"title":"obsidian文章发布到hexo攻略","url":"/obsidian%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%88%B0hexo%E6%94%BB%E7%95%A5/","content":"目标\n将obsidian中带有反向链接的markdown文章在hexo中正常显示\n快速添加文章头部的标题、时间、标签等\n\n使用的软件/项目\nobsidian\nvscode\nmarkdownlint插件\nCyrusky/hexo-backlink\n\n迁移项目文件首先，复制要发布的文档到_post文件夹。然后在vscode中打开hexo文件夹。\n规范markdown格式vscode中安装markdownlint插件，启用后打开要发布的文章，打开问题面板。这时可能会检测出几个问题，右键选择一个问题，点击即可一键规范格式。\n使用用户片段在vscode中选择文件-设置-用户片段，选择新建“xxx”文件夹的代码片段文件，随便取个名字然后回车。然后把下面的代码黏贴到大括号里面\n &quot;xxx&quot;: &#123; &quot;scope&quot;: &quot;&quot;, &quot;prefix&quot;: &quot;xxx&quot;, &quot;body&quot;: [  &quot;---&quot;,  &quot;title: $TM_FILENAME_BASE&quot;, &quot;date:$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE$CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;,  &quot;tags:&quot;,  &quot;- $1&quot;,  &quot;categories: $2&quot;,  &quot;---&quot; ], &quot;description&quot;: &quot;xxx&quot; &#125;,\n\n把第一个xxx随便取个名字，第二个输入一个随便的单词，第三个随便写个描述，然后保存。接下来按ctrl+shift+p打开命令面板，输入json，选择首选项：打开工作区设置，会打开一个json文件，然后把里面的内容替换为下面的代码\n&#123; &quot;[markdown]&quot;: &#123; &quot;editor.quickSuggestions&quot;: true &#125;&#125;\n\n现在你已经开启可输入建议，可以使用代码片段了。打开你的文章，在首行输入你设定的第二个xxx中的单词，按下tab，就会自动生成一段片段，完成添加。\n正常显示反向链接打开终端，输入npm install hexo-backlink等待安装完成（项目文档），该插件会在生成时自动转换反向链接。\n示例利用github发布的博客\n","categories":["hexo教程"],"tags":["obsidian","hexo"]},{"title":"Csharp读书笔记（二）-数组","url":"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E7%BB%84/","content":"数组\n数组是一组变量，可以存储和修改多个数据\n\n创建数组时，需要指定类型、名称和元素数量\n\n可以为引用创建数组，但是创建时只会创建引用变量，不会创建实例\n\n必须分别为每一个对象创建实例\n\n数组的索引是从0开始的\n\n比如，创建一个元素数量为6的int数组，int[] numbers=new int[6]，此时访问numbers[5]，这时获取的元素为第6个\n\nRandom类可以随机生成数字\n\n使用时，先创建实例，再使用Next()方法，举例：调用GetRandom()时，以下代码会返回一个9到100间的随机整数\npublic Random Randomizer;public int GetRandom()&#123;  return(Randomizer.Next(9,100));&#125;\n对价格使用decimal类型时，要在值后面加上M\n\n\n","categories":["Csharp读书笔记"],"tags":["csharp","hfc"]},{"title":"Csharp读书笔记（一）-对象与引用","url":"/Csharp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8/","content":"这个系列是head first csharp书籍的读书笔记，总结提炼了一些C#的核心内容，以及自己的个人理解。\n程序从哪里来\nIDE是一种方便的文件编辑器\n.NET提供很多工具来帮助你完成任务\n程序在CLR中运行\nusing语句让你可以使用其他命名空间中的类\n命名空间包含类，类包含方法，方法由语句组成\n方法前的类型指出了这个方法的返回值，方法后的括号中包含参数\n\n对象\n由一个类创建新对象时，称为这个类的一个实例 ^be690f\n使用new关键字创建实例\n静态类不用创建实例，但其他类需要创建实例才能使用\n可以在类中包含静态方法，使用它们时不用创建实例\n实例使用字段来跟踪其状态 ^52e61c\n每个实例都会有自己的变量副本\n创建对象时，会放在内存中的一个部分，称作堆\n类图可以帮助你组织类\n\n创建类图\n画一个矩形方框\n在顶部写出字段\n画一条横线\n在下方写出方法\n\n引用\n对象的一个引用叫做引用变量\n引用像标签，可以通过标签找到对象\n一个对象可以有多个引用，就像你可以给一个瓶子贴多个标签\n引用可以移动\n一个没有引用的对象会被垃圾回收\n移动引用：\n\nmyclass class1=new myclass();myclass class2=new myclass();class1=class2;\n\n\n这样做把class2指向的myclass实例“赋值”给class1这个引用，相当于把class2指向的myclass实例贴上了class1的标签，也就是把class1的引用移动到class2上面，这样原来class1指向的对象会被垃圾回收！  \n\n","categories":["Csharp读书笔记"],"tags":["csharp","hfc"]},{"title":"qnap搭建rss全攻略","url":"/qnap%E6%90%AD%E5%BB%BArss%E5%85%A8%E6%94%BB%E7%95%A5/","content":"目标在qnap nas上搭建ttrss、rsshub，并通过fluent reader连接到所搭建的服务，实现多端同步。过程中踩了很多坑，所以这篇文章将列出所有遇到的坑，完整详细地讲解如何搭建一个可以正常使用的rss系统。\nnas搭建教程awesome ttrss （文档）简介一个一站式rss客户端解决方案，可以多端同步浏览记录。其中的fever插件允许应用程序接入。\n创建数据库文件夹ttrss需要数据库来保存文件。在File station中Container共享文件夹中右键创建文件夹，右键新建的文件夹选择属性，记下文件路径。\n注意：显示的文件路径不全，需要在前面补上/share，在后面补上/文件夹名称，最终路径应该像这样：/share/.../文件夹名称\n使用docker安装qnap提供container station，可以运行docker容器。首先在app center里安装container station（这里已经装好）:\n\n打开之后选择创建(create)，右上角选择create application:\n弹出一个窗口，随便取个名字，然后把下面的代码粘贴到YAML一栏（这段代码在官方文档里有）：\nversion: &quot;3&quot;services:  service.rss:    image: wangqiru/ttrss:latest    container_name: ttrss    ports:      - 181:80    environment:      - SELF_URL_PATH=http://ip:181/ # please change to your own domain      - DB_PASS=ttrss # use the same password defined in `database.postgres`      - PUID=1000      - PGID=1000      - ALLOW_PORTS=1200    volumes:      - feed-icons:/var/www/feed-icons/    networks:      - public_access      - service_only      - database_only    stdin_open: true    tty: true    restart: always  service.mercury: # set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page    image: wangqiru/mercury-parser-api:latest    container_name: mercury    networks:      - public_access      - service_only    restart: always  service.opencc: # set OpenCC API endpoint to `service.opencc:3000` on TTRSS plugin setting page    image: wangqiru/opencc-api-server:latest    container_name: opencc    environment:      - NODE_ENV=production    networks:      - service_only    restart: always  database.postgres:    image: postgres:13-alpine    container_name: postgres    environment:      - POSTGRES_PASSWORD=ttrss # feel free to change the password    volumes:      - 数据库路径:/var/lib/postgresql/data # persist postgres data to ~/postgres/data/ on the host    networks:      - database_only    restart: always  # utility.watchtower:  #   container_name: watchtower  #   image: containrrr/watchtower:latest  #   volumes:  #     - /var/run/docker.sock:/var/run/docker.sock  #   environment:  #     - WATCHTOWER_CLEANUP=true  #     - WATCHTOWER_POLL_INTERVAL=86400  #   restart: alwaysvolumes:  feed-icons:networks:  public_access: # Provide the access for ttrss UI  service_only: # Provide the communication network between services only    internal: true  database_only: # Provide the communication between ttrss and database only    internal: true\n\n粘贴后，修改ip、数据库路径。ip即nas的ip地址，数据库路径即在第一步中创建的文件夹路径。\n注意：其中allow_ports为除80,443端口外ttrss可以访问的端口号，这里设置为1200是为了rsshub能够正常订阅。\n设置完成后，点确定就可以创建ttrss了。等待一段时间，装好后访问http://ip:181/就可以访问到ttrss界面了。\n设置ttrss打开ttrss后，默认账号admin，密码password。在右上角偏好设置-用户里可以改。\n启用fever插件为了让客户端可以访问ttrss，必须借助fever插件。偏好设置-偏好设置-Fever Emulation里设个密码：\n连接fever（以开源的fluent reader为例，支持windows,ios,android等平台）打开设置，选择服务，fever api。在“端点”中填入http://ip:181/plugins/fever/。用户名为ttrss用户名，密码是fever插件中设置的密码，不是ttrss的密码！\n到此，ttrss设置完毕，可以正常订阅、阅读rss内容了。下面配置rsshub。\nrsshub（文档）简介一个可以为不提供rss站点生成rss的项目。\ndocker搭建因为这次不需要多个容器（ttrss需要有数据库和本体），所以不需要输入代码，所有操作都可以在图形界面进行，首先安装rsshub容器（从左到右按照图示操作）：\n版本选latest，到最后选择advanced settings&gt;&gt;，选择network一栏，把network mode调成bridge，选择use static IP，把ip address改成不同于nas的（一般改最后一位即可）。\n注意：请根据实际网络情况配置该项。\n为什么要这么做？\n实际测试无法自己访问自己，所以将容器独立出来，为它在局域网内分配一个单独ip，即可正常访问。\n接下来建立容器，等待一段时间后访问ip:1200，若出现welcome to rsshub即建立成功。\n到此，所有配置全部完成，应该可以正常使用了。\n","categories":["qnap教程"],"tags":["qnap","rss"]},{"title":"windows UAC跳过教程","url":"/windowsUAC%E8%B7%B3%E8%BF%87%E6%95%99%E7%A8%8B/","content":"什么是UAC安装软件时、运行部分程序时弹出的窗口就是UAC，比如下面这个以管理员权限运行的记事本\n有时候，运行一些程序可能需要管理员权限，比如某些电脑清理软件。\n第一种方法：直接关闭UAC\n打开控制面板-系统和安全-安全和维护\n在用户账户控制那里点击更改设置\n下拉到“从不通知”\n\n第二种方法：使用任务计划程序\n右键windows图标\n选择计算机管理\n选择左侧的任务计划程序-任务计划程序库\n点击右侧“创建任务…”\n名称随便填，勾选\n操作一栏中选择新建，弹出这么个窗口：\n这里就选择启动程序，点浏览，选择要跳过UAC的程序，确定保存\n根据需要设定剩下的条件、设置、触发器\n如果需要开机启动，请选择登录时，不要选择启动时（因为要登陆再启动程序）\n设置完成，现在添加一个对于新建的任务的快捷方式：在电脑桌面上右键新建-快捷方式，位置一栏输入SCHTASKS /RUN /TN 任务名称，把任务名称改为在第5步中创建的名称\n现在建立了快捷方式，双击桌面上的图标即可跳过UAC运行软件~\n\n","categories":["windows教程"],"tags":["windows","UAC"]},{"title":"使用windows计划任务实现插入移动硬盘自动运行程序","url":"/%E4%BD%BF%E7%94%A8windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/","content":"思路在系统计划任务中，有一个“发生事件时”的触发器。这让插入移动硬盘自动运行程序成为了可能。所以只要找到插入硬盘时触发的系统事件，即可实现。在事件查看器中，通过筛选，我发现插入硬盘时，触发了来源为DistributedCOM的警告事件，ID为10016。\n实现方法\n插入移动硬盘\n右键开始菜单图标，选择计算机管理，选择系统工具-事件查看器-windows日志-系统，找到刚刚插入硬盘发生的DistributedCOM事件，如下图\n右键这个警告事件，选择将“任务附加到此事件”，通过这个向导即可创建一个自动任务。\n\n用途这个功能用途很多，比如插入后自动运行备份程序，关键看需求。\n","categories":["windows教程"],"tags":["windows","任务计划程序"]}]